[
{
	"uri": "https://lczen.github.io/en/showcase/hugo/hugo-theme-zzo/",
	"title": "Hugo Zzo Theme",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Make a blog with hugo zzo theme!",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/showcase/hugo/hugo-theme-zdoc/",
	"title": "Hugo zDoc Theme",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Make a documentation with hugo zdoc theme!",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/tags/numpy/",
	"title": "numpy",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/",
	"title": "Posts",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Post page",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/",
	"title": "数据分析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/dataanalysis/",
	"title": "数据分析包",
	"tags": ["numpy"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "1 2 3 4  a = np.array([[1,2,3], [4,5,6]]) b= np.random.random((2,2)) # astype做类型转换 a.astype(np.float)   数组索引与切片/Array indexing and slicing\n"
},
{
	"uri": "https://lczen.github.io/en/tags/python%E7%BB%83%E4%B9%A0%E9%A2%98/",
	"title": "python练习题",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/pythonpractice2/",
	"title": "python练习题2",
	"tags": ["python练习题"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "1 2 3 4 5 6  def test(got, expected):#测试函数 if got == expected: prefix = \u0026#39;正确!\u0026#39; else: prefix = \u0026#39;错误!\u0026#39; print(\u0026#39;%s你的结果: %s应该返回的结果: %s\u0026#39; % (prefix, repr(got), repr(expected)))   数据结构题 习题3 输入一个非空的元组列表，返回按列表中元组的最后一个元素从小到大排序后的元组列表\n例如：输入：[(1, 7), (1, 3), (3, 4, 5), (2, 2)]应该返回：[(2, 2), (1, 3), (3, 4, 5), (1, 7)]\n提示：使用自定义键=函数从每个元组提取最后一个元素。\n1 2 3 4 5 6 7 8 9 10  def last(a): return a[-1] def sort_last(tuples): # +++your code here+++ # LAB(begin solution) return sorted(tuples, key=last) return sorted(tuples, key=lambda d: d[-1]) # 可运行代码自测 test(sort_last([(1, 3), (3, 2), (2, 1)]),[(2, 1), (3, 2), (1, 3)])   习题4 输入一个数字列表，将所有相邻且相同的元素去重保留一个元素后返回\n例如：输入[1, 2, 2, 3] 返回 [1, 2, 3]；输入[1, 1, 2, 2, 3, 3, 3] 返回 [1, 2, 3]\n新建一个列表或者修改原来的列表返回均可。\n1 2 3 4 5 6 7 8 9 10 11 12  def remove_adjacent(nums): # +++your code here+++ # LAB(begin solution) result = [] for num in nums: if len(result) == 0 or num != result[-1]: result.append(num) return result # 可运行代码自测 test(remove_adjacent([1, 2, 2, 3]), [1, 2, 3]) test(remove_adjacent([2, 2, 3, 3, 3]), [2, 3]) test(remove_adjacent([]), [])   习题5 习题5 给定两个按递增顺序排序的列表,创建并返回一个合并的按排序排列的所有元素的列表。\n例如输入 [\u0026lsquo;aa\u0026rsquo;, \u0026lsquo;xx\u0026rsquo;, \u0026lsquo;zz\u0026rsquo;], [\u0026lsquo;bb\u0026rsquo;, \u0026lsquo;cc\u0026rsquo;]，应该返回[\u0026lsquo;aa\u0026rsquo;, \u0026lsquo;bb\u0026rsquo;, \u0026lsquo;cc\u0026rsquo;, \u0026lsquo;xx\u0026rsquo;, \u0026lsquo;zz\u0026rsquo;]\n希望你提供的解决方案在“线性”时间内工作，使两个列表都可以一次完成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def linear_merge(list1, list2): # +++your code here+++ # LAB(begin solution) result = [] # Look at the two lists so long as both are non-empty. # Take whichever element [0] is smaller. while len(list1) and len(list2): if list1[0] \u0026lt; list2[0]: result.append(list1.pop(0)) else: result.append(list2.pop(0)) # Now tack on what\u0026#39;s left result.extend(list1) result.extend(list2) return result   习题5 考虑把一个字符串拆分成两个等分\n 1.如果字符串长度是偶数，前一半和后一半的长度是相同的 2.如果字符串长度是奇数，则多出的一个字符加到前一半，如：\u0026lsquo;abcde\u0026rsquo;，前一半是'abc\u0026rsquo;，后一半是'de\u0026rsquo; 3.输入两个字符串, a 和 b,按以下格式返回结果  a-front + b-front + a-back + b-back    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def front_back(a, b): # +++your code here+++ # LAB(begin solution) # Figure out the middle position of each string. a_middle = len(a) // 2 b_middle = len(b) // 2 if len(a) % 2 == 1: # add 1 if length is odd a_middle = a_middle + 1 if len(b) % 2 == 1: b_middle = b_middle + 1 return a[:a_middle] + b[:b_middle] + a[a_middle:] + b[b_middle:] # 可运行代码自测 test(front_back(\u0026#39;abcd\u0026#39;, \u0026#39;xy\u0026#39;), \u0026#39;abxcdy\u0026#39;) test(front_back(\u0026#39;abcde\u0026#39;, \u0026#39;xyz\u0026#39;), \u0026#39;abcxydez\u0026#39;) test(front_back(\u0026#39;Kitten\u0026#39;, \u0026#39;Donut\u0026#39;), \u0026#39;KitDontenut\u0026#39;)   综合练习题 编写程序完成以下任务：\n读取指定的文件，并使用split()函数以空白为字符串分隔得到文件中所有的单词。\n完成一个名为mimic_dict的函数：\n 以出现在文件中的单词(全都小写化)为键(key)，文件中所有紧跟在单词后面的一个单词组成的列表为值(value)。单词列表可以是任意顺序的，也可以包含重复的值。\n例如，键“and”可能有列表[\u0026ldquo;then\u0026rdquo;, \u0026ldquo;best\u0026rdquo;, \u0026ldquo;then\u0026rdquo;, \u0026ldquo;after\u0026rdquo;, \u0026hellip;]，此列表包括了所有的文件中在'and'后面的单词。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  def mimic_dict(filename): \u0026#34;\u0026#34;\u0026#34;Returns mimic dict mapping each word to list of words which follow it.\u0026#34;\u0026#34;\u0026#34; # +++your code here+++ # LAB(begin solution) mimic_dict = {} f = open(filename, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) text = f.read() f.close() words = text.split() prev = \u0026#39;\u0026#39; for word in words: if not prev in mimic_dict: mimic_dict[prev] = [word] else: mimic_dict[prev].append(word) # Could write as: mimic_dict[prev] = mimic_dict.get(prev, []) + [word] # It\u0026#39;s one line, but not totally satisfying. prev = word return mimic_dict def print_mimic(mimic_dict, word): \u0026#34;\u0026#34;\u0026#34;Given mimic dict and start word, prints 200 random words.\u0026#34;\u0026#34;\u0026#34; # +++your code here+++ # LAB(begin solution) for unused_i in range(200): print(word,) nexts = mimic_dict.get(word) # Returns None if not found if not nexts: nexts = mimic_dict[\u0026#39;\u0026#39;] # Fallback to \u0026#39;\u0026#39; if not found word = random.choice(nexts) filename = \u0026#39;../data/sample_text.txt\u0026#39; mimic_dict = mimic_dict(filename) print_mimic(mimic_dict, \u0026#39;\u0026#39;)   "
},
{
	"uri": "https://lczen.github.io/en/categories/%E7%BB%83%E4%B9%A0%E9%A2%98/",
	"title": "练习题",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/pythonpractice3/",
	"title": "python练习题3",
	"tags": ["python练习题"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "文件读写练习题 请对“Shanghai.txt”文件进行读取，并统计其中每个单词(小写后)出现的词频，并以词频从高到低以如下形式写入\u0026quot;word_count.txt\u0026quot;中：\n单词1:频次 单词2:频次 ... 最后请输出10行结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import re,collections def get_words(in_file, out_file): with open (in_file, encoding=\u0026#39;utf-8\u0026#39;) as f: words_box=[] for line in f: words = line.strip().strip(\u0026#34;,\u0026#34;).strip(\u0026#34;.\u0026#34;).split() words = list(map(lambda x:x.lower(), words)) words_box.extend(words) word_dic = dict(collections.Counter(words_box)) word_count = sorted(word_dic.items(), key=lambda d: d[1], reverse=True) out = open(out_file, \u0026#39;w\u0026#39;) for word in word_count: out.write(word[0]+\u0026#34;:\u0026#34;+str(word[1])+\u0026#34;\\n\u0026#34;) out.close() get_words(\u0026#34;../data/ShangHai.txt\u0026#34;, \u0026#39;../../tmp/word_count.txt\u0026#39;)   正则表达式练习题 给出一段XX音乐中的HTML内容，用正则表达式取出html中所有的歌手名和歌名。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 取出html中的歌手名和歌名 html = \u0026#39;\u0026#39;\u0026#39;\u0026lt;div id=\u0026#34;songs-list\u0026#34;\u0026gt;\u0026lt;h2 class=\u0026#34;title\u0026#34;\u0026gt;经典老歌\u0026lt;/h2\u0026gt;\u0026lt;p class=\u0026#34;introduction\u0026#34;\u0026gt;经典老歌列表\u0026lt;/p\u0026gt;\u0026lt;ul id=\u0026#34;list\u0026#34;class=\u0026#34;list-group\u0026#34;\u0026gt;\u0026lt;li data-view=\u0026#34;2\u0026#34;\u0026gt;一路上有你\u0026lt;/li\u0026gt;\u0026lt;li data-view=\u0026#34;7\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/2.mp3\u0026#34;singer=\u0026#34;任贤齐\u0026#34;\u0026gt;沧海一声笑\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;li data-view=\u0026#34;4\u0026#34;class=\u0026#34;active\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/3.mp3\u0026#34;singer=\u0026#34;齐秦\u0026#34;\u0026gt;往事随风\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;li data-view=\u0026#34;6\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/4.mp3\u0026#34;singer=\u0026#34;beyond\u0026#34;\u0026gt;光辉岁月\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;li data-view=\u0026#34;5\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/5.mp3\u0026#34;singer=\u0026#34;陈慧琳\u0026#34;\u0026gt;记事本\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;li data-view=\u0026#34;5\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/6.mp3\u0026#34;singer=\u0026#34;邓丽君\u0026#34;\u0026gt;但愿人长久\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026lt;/ul\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;\u0026#39;\u0026#39; import re def get_singer_songs(html_content): # 请完成题目要求 # your code here result = re.search(\u0026#39;\u0026lt;li.*?singer=\u0026#34;(.*?)\u0026#34;\u0026gt;(.*?)\u0026lt;/a\u0026gt;\u0026#39;, html_content, re.S) if result: print(result.group(1), result.group(2)) return result r = get_singer_songs(html) print(r)   "
},
{
	"uri": "https://lczen.github.io/en/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
	"title": "读书笔记",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/tags/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/",
	"title": "非暴力沟通",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/readingnotes/",
	"title": "非暴力沟通",
	"tags": ["非暴力沟通"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "提出请求 请让我成为我自己。 5.如果你选择这一句，我们意见不一致。对我来说，“让我成为我自己”是一个模糊的请求。如果发言者说“我希望你告诉我，即使你不喜欢我做的一些事情，你仍然会和我在一起”，那么，我认为发言者提出了明确的请求。\n6.关于昨天的会议，请不要隐瞒你的看法。 6.如果你选择这一句，我们意见不一致。对我来说，“不要隐瞒”是一个模糊的请求。如果发言者说“请告诉我，你怎么看我昨天在会议中的表现，给我一些建议好吗”，那么，我认为发言者提出了明确的请求。\n马歇尔•卢森堡. 非暴力沟通 (Kindle 位置 953-955).\n7.我希望你能在规定的时速内驾驶。 8.我想更好地了解你。 8.如果你选择这一句，我们意见不一致。如果发言者说“我想多一些时间和你聊聊，不知道你是否愿意每周和我吃一次午饭”，那么，我认为发言者提出了明确的请求。\n9.我希望你尊重我的个人隐私。 9.如果你选择这一句，我们意见不一致。对我来说，“尊重我的个人隐私”这个短语并不能清楚地表达发言者的请求。如果发言者说“在进我的办公室前，请先敲门好吗”，那么，我认为发言者提出了明确的请求。\n10.我希望你经常做晚饭。 10.如果你选择这一句，我们意见不一致。对我来说，“经常”这个词并不能清楚地表达发言者的请求。如果发言者说“我希望你每周一晚上都可以做晚饭”，那么，我认为发言者提出了明确的请求。\n倾听 倾听之前的准备 为了倾听他人，我们需要先放下已有的想法和判断，全神贯注地体会对方。以色列哲学家马丁·布伯（MartinBuber）对此作出了描述：“尽管有种种相似之处，生活的每时每刻就像一个刚出生的婴儿，一张新的面孔，我们从未见过，也不可能再次见到。我们无法停留在过去，也无法预见我们的反应。我们需要不带成见地感受变化。我们需要用全身心去倾听。”\n倾听的作用\u0026mdash;工具人\n感受与需要 男：和你说话有什么用？你从不好好听。\n马歇尔：“你现在关心的是他的想法而非他的需要。我想，如果我们注意的是别人的需要而非他对我们的看法，我们将发现别人并不那么可怕。我们还会发现，他不高兴是因为他的需要没有得到满足。”\n（wrong）女：你感到不高兴，是因为你觉得我不理解你？\n女：你不高兴是因为你需要得到理解？\n给他人反馈 在倾听他人的观察、感受、需要和请求之后，我们可以主动表达我们的理解。如果我们已经准确领会了他们的意思，我们的反馈将帮助他们意识到这一点。反之，如果我们的理解还不到位，他们也就有机会来纠正我们。此外，这样做还有助于人们体会自己的状况，从而深入了解自己。\n使用疑问句给予反馈 非暴力沟通建议我们使用疑问句来给予他人反馈。这将便于他人对我们的理解作出必要的补充。问题可以集中于以下几个方面：\n1.他人的观察：“上周我有三个晚上不在家，你说的是这回事？”\n2.他人的感受及需要：“你很灰心？你希望得到肯定是吗？”\n3.他人的请求：“你是不是想请我帮你预订酒店？”\n以下没有用心体会他人：\n1.“你说的是什么事？”（我有些困惑。我想知道你是指哪件事。告诉我好吗？[感受+需要]）\n2.“你现在心情怎么样？”“为什么你会有那样的感觉？”\n3.“你希望我怎么做？”\n一般来说，如果一个人在说话时有明显的情绪，他一般会期待得到他人的反馈。\n只要我们专注于他人的感受和需要，所有的批评、攻击、辱骂或嘲讽就会消失。我们越是这样做，就越能体会到一个简单的事实：有时，我们认为自己受到了指责，实际上，那些话是他人表达需要和请求的方式。如果意识到这一点，我们就不会认为自己的人格受到了伤害。反之，如果一心分析自己或对方的过错，我们就会认为自己被贬低了。\n反馈是有价值的 wrong:\n太太：你从不好好听我讲话。\n丈夫：我哪里没有？\n太太：你就是没有！\nright:\n太太：你从不好好听我讲话。\n丈夫：听起来，你很失望。你需要体贴，是吗？\n太太：流下了眼泪\n保持关注 在谈话刚开始时，人们所表达的感受往往是冰山之一角，有许多相关的感受——通常是更为强烈的情感，并没有得到表达。倾听将为他们探究和表达内心深处的感受创造条件。反之，如果急于了解他们的请求或表达自己，就会妨碍这个过程。\n实例：母亲与我的对话\n母亲：不知道怎么回事，我的孩子不论我和他说什么，他都不听。\n我（表达理解和她的需要）：听起来，你很伤心，你希望找到和孩子沟通的办法。\n母亲：也许这是我的错。我总是冲他大喊大叫。”\n我（继续倾听并给予反馈）：你希望你能多体贴孩子，以前没有做到这一点，你现在有些内疚，是吗？\n母亲：我是一个失败的母亲。\n我（理解+反馈）：你有些灰心，你想加深与孩子的感情联系，是吗？\n我（不确定对方已经充分表达）：你还有什么话要告诉我吗？\n当我们痛苦得无法倾听 当我们痛苦得无法倾听他人时，我们需要\n（1）体会自己的感受和需要；\n（2）大声地提出请求；\n（3）换一个环境。\n倾听他人并给予反馈 1.甲：“我又误机了，我真是个混蛋！”乙：“没有人是十全十美的，不要太严格要求自己。” 你很失望，是因为你希望能够信赖自己，是吗？\n2.甲：“我认为我们应该把这些非法移民遣送回国。”乙：“这对改善社会治安有帮助吗？” 你有些担心，因为你很看重社会秩序和安全？\n3.甲：“你以为你什么都知道？！” 乙：“听起来，你有些不耐烦，因为你希望每个人的意见都能得到倾听？”\n4.甲：“你从不把我当回事。要不是我帮你，你自己一个人能处理这么多事情吗？”乙：“你怎么能这样想！我一直都很尊重你。” 你好像有些失落，你希望得到欣赏和肯定？\n5.甲：“你怎么可以那样和我说话？”乙：“我那样说话，你是不是很伤心？” 听起来，你很伤心，因为你需要体贴？\n6.甲：“想到我先生，我就有些气恼。我需要他的时候，他总是不在我身边。”乙：“你是希望他多陪陪你？” 听起来，你有些失落，因为你需要支持与关心？（反馈：感受+需要）\n7.甲：“我真受不了我自己，我现在变得这么胖！”乙：“慢跑也许会有帮助。” 你对自己好像有些不耐烦，你很看\n马歇尔•卢森堡. 非暴力沟通 (Kindle 位置 1178-1179).\n8.甲：“我紧张地筹备女儿的婚礼。可是，我亲家老是有新主意，真烦！”乙：“听起来，你有些着急，你希望能得到理解与配合，是吗？” 9.甲：“如果亲戚来之前不和我打招呼，我真的不想接待他们。”乙：“我知道这是什么感觉。我也这样。” 你是不是有些厌烦，你希望你的需要也能得到尊重，是吗？\n10.甲：“你的表现让我很失望。我本来指望你们部门上个月的产出能够翻番。”乙：“我知道你很失望。但上个月我们部门请病假的人很多。” 你看来很失望，你看重工作效率，是吗？\n第八章倾听的力量 倾听使身心痊愈 "
},
{
	"uri": "https://lczen.github.io/en/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/websites/",
	"title": "资源下载",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "网站标签 http://www.yunpangou.com/2154977354010695\n"
},
{
	"uri": "https://lczen.github.io/en/posts/pythonpractice1/",
	"title": "pythn练习题1",
	"tags": ["python练习题"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "简答题 请谈谈Python中is 和 == 的区别 is用于比较两个变量是否引用了同一个内存地址 is 表示的是对象标示符（object identity），作用是用来检查对象的标示符是否一致，也就是比较两个对象在内存中的地址是否一样。\n==用于比较两个变量的值是否相等,== 表示的是相等（equality），是用来检查两个对象是否相等。\nis 是检查两个对象是否指向同一块内存空间，而 == 是检查他们的值是否相等。\n可以看出，is 是比 == 更严格的检查，is 返回True表明这两个对象指向同一块内存，值也一定相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # case 1:对于数值型和字符串型对象, python的存储机制使得a和b其实指向同一个地址，所以is和==都是True a = 5 b = 5 print(\u0026#39;a is b:\u0026#39;, a is b) print(\u0026#39;a == b:\u0026#39;, a == b) print(\u0026#39;id(a):%s\\nid(b):%s\u0026#39;%(id(a),id(b))) print(\u0026#39;\\n\u0026#39;) # case 2:对于list、tuple等容器，a和b虽然内容一样，但是是两个不同的对象引用，指向两个不同的内存地址 a = [1,2,3] b = [1,2,3] print(\u0026#39;a is b:\u0026#39;, a is b) print(\u0026#39;a == b:\u0026#39;, a == b) print(\u0026#39;id(a):%s\\nid(b):%s\u0026#39;%(id(a),id(b))) print(\u0026#39;\\n\u0026#39;) # case 3：实际上可以通过修改对象的__eq__方法改变==的比较方式 class Student(): def __init__(self, name, age): self.name = name self.age = age def __eq__(self, other): # return self.name == other.name return False s1 = Student(\u0026#39;David\u0026#39;,18) s2 = Student(\u0026#39;David\u0026#39;,20) # 因为age不相同，很显然s1和s2是两个不同内容的对象，但是通过改写__eq__可以只通过比较名字来判断是否== print(\u0026#39;s1 is s2:\u0026#39;, a is b) print(\u0026#39;s1 == s2:\u0026#39;, a == b) print(\u0026#39;id(s1):%s\\nid(s2):%s\u0026#39;%(id(s1),id(s2)))   a is b: True\na == b: True\nid(a):1871024336\nid(b):1871024336\na is b: False\na == b: True\nid(a):3008335707656\nid(b):3008335707848\ns1 is s2: False\ns1 == s2: True\nid(s1):3008335765400\nid(s2):3008335765456\nPython中的高阶函数是指什么？ 提示：我们指的是map、reduce、filter这类函数\n高阶函数属于函数式编程中的一个概念。在python中函数是一个对象，这意味着可以使用其他变量引用函数。\npython里的高阶函数，即接受函数作为参数的函数。\npython中的常用的高阶函数有：\nmap: 可理解为对数据的做一对一映射\nreduce: 可理解为对数据做多对一的映射\nfilter: 对数据进行逐个过滤，仅保留符合条件的元素\nPython类中有哪些的成员，如何分类他们，他们各自又有哪些用途？ 提示：成员变量，成员函数\u0026hellip;\n数据成员\n类变量 : 在类中且函数体之外,实例之间共享\n实例变量 : 定义在init方法中,作用于当前实例的类\n方法成员\n类方法 : 用@classmethod装饰器,第一个参数为cls\n实例方法 : 绑定到实例的方法, 第一个参数为self\n静态方法 :\n 用@staticmethod装饰器\n没有cls self参数限制\n可以类名访问,也可以实例访问\n Python中列表，元组的相同之处及区别都有哪些？集合与字典呢？ 列表与元组\n相同点：\n列表与元组都是容器，是一系列的对象\n都可以包含任意类型的元素甚至可以是一个序列，还可以包含元素的顺序\n不同点：\n列表是可变的，而元组是不可变的，tuple 不可追加，tuple大小不可再改变。\n不能把列表当做字典的关键字，因为只有不可变的值才能进行哈希运算，因此只有不可变的值才能作为关键字。要使用列表做关键字，你需要把它转化为元组\n集合与字典\n相同点：\ndict和set当中都没有重复的key值，且key值必须是不可改变的对象。\n两者存储的元素都是无序的。\n不同点：\nset是一组key的集合，但不存储value；\ndict使用键-值（key-value）存储，具有极快的查找速度。\nPython中的模块和包是什么，如何自定义并使用？ 模块\n一个模块就是一个.py文件，里面定义了可以复用的函数和变量，当需要复用的时候就import导入进来进行复用\n自定义：创建一个.py文件就是文件名就是模块名称\n使用：使用import导入进来使用，搜索目录有当前路径、Bif中查找、安装路径、PYTHONPATH环境变量路径，找到该模块则可以导入并使用模块名.方法名的方式调用模块中的方法\n包\n就是多个模块或着多个包的集合（文件夹），避免由于开发者多而可能造成的模块命名重复，所以用包来统一管理模块\n自定义：给多个模块创建一个文件夹，文件夹内可以有模块（.py文件）或者文件夹（子包），并且需要包含一个init.py文件，用来做一些初始化工作和避免被解释器当作普通字符串\n使用：\n同样是使用import的方式导入到当前脚本中\n代码题 创建一个函数，接收一个字符串参数，判断其做为Python标识符是否合法。 具体要求：\n 如果合法则输出 True，否则输出 False。 如果该字符串与Python内置的关键字，或Bifs冲突，则打印'conflict\u0026rsquo; 注:Python标识符的规则，关键字和Bifs可搜索得到  1 2 3 4 5 6 7 8 9 10 11 12 13 14  import keyword,string def Identifier(s): kw = keyword.kwlist if s in kw or s in dir(__builtins__): print(\u0026#34;conflict\u0026#34;) elif s.isidentifier(): # isidentifier() 可用来判断变量名是否合法 print(\u0026#34;True\u0026#34;) else: print(\u0026#34;False\u0026#34;) Identifier(\u0026#34;list\u0026#34;) Identifier(\u0026#34;abc#\u0026#34;) Identifier(\u0026#34;1a\u0026#34;)   编写一个函数，能生成包含20个随机整数的列表，然后将前10个元素升序排列，后10个元素降序排列，并分别打印输出 提示：本题考察对列表的切片和排序操作，注意切片下标。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import random def sort2part(): ran_list = [] for i in range(20): ran_list.append(random.randint(0,100)) ran_list_pre_10 = ran_list[0:10] ran_list_pre_10.sort() ran_list_last_10 = ran_list[10::] ran_list_last_10.sort(reverse=True) print(\u0026#34;前十个随机数 升序: \u0026#34;+ str(ran_list_pre_10)) print(\u0026#34;后十个随机数 降序: \u0026#34; + str(ran_list_last_10)) sort2part()   有一分数序列为：2/1，3/2，5/3，8/5，13/8，21/13,请使用Python代码出生成并打印该数列的前30项并求和返回 提示：观察分数的分子和分母，每1项都和前2项有关系，也可检索“斐波那契数列”\n1 2 3 4 5 6 7 8 9 10 11  def fab(max): n, a, b = 0, 2, 1 result = 0 while n \u0026lt; max: print(\u0026#34;%d/%d\u0026#34;%(a,b)) result += a/b a, b = a + b, a n += 1 return result print(\u0026#34;该数列的前30项和: \u0026#34;,fab(30))    2/1\n3/2\n5/3\n8/5\n13/8\n21/13\n34/21\n55/34\n89/55\n144/89\n233/144\n377/233\n610/377\n987/610\n1597/987\n2584/1597\n4181/2584\n6765/4181\n10946/6765\n17711/10946\n28657/17711\n46368/28657\n75025/46368\n121393/75025\n196418/121393\n317811/196418\n514229/317811\n832040/514229\n1346269/832040\n2178309/1346269\n该数列的前30项和: 48.84060068717216\n BMI编写 身体质量指数（BMI）是根据人的体重和身高计算得出的一个数字，BMI是可靠的身体肥胖指标，其计算公式：BMI=Weight/High2，其中体重单位为公斤，身高单位为米。\n 计算公式为：$BMI=体重（kg）÷身高^2（m）$ 提示用户输入体重（kg）和身高的数字(m)(注意单位），然后计算BMI。 根据BMI指数范围，定义当前健康状态。BMI指数在18至25之间定义为健康的标准体重,小于该范围定义为偏瘦，超过该范围定义为偏重。 将BMI指数和其所代表状态输出  1 2 3 4 5 6 7 8 9 10 11  weight = float(input(\u0026#39;请输入您的体重：\u0026#39;)) high = float(input(\u0026#39;请输入您的身高：\u0026#39;)) BMI = weight / (high**2) weight_result = \u0026#34;健康的标准体重\u0026#34; if BMI \u0026gt; 25: weight_result = \u0026#34;偏重\u0026#34; elif BMI \u0026lt; 18: weight_result = \u0026#34;偏瘦\u0026#34; else: pass print(\u0026#39;您的BMI指数为%.2f，您的体重为%s\u0026#39;%(BMI,weight_result))   字符统计  创建一个函数，接收字符串输入，分别统计出其中英文字母、空格、数字和其它字符的个数后打印。 提示：  ord(\u0026lsquo;a\u0026rsquo;) 能将字符 \u0026lsquo;a\u0026rsquo; 转化为 ASCII 码表上对应的数值， 例如，空格为32 数字 0-9 对应的码值为 48-57 大写字母 A-Z 对应 65-90 小写字母 a-z 对应 97-122 比122高的都是其它。    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def str_count(s): count_a=count_z=count_o=count_s=0 for i in s: if (ord(i)\u0026gt;=97 and ord(i)\u0026lt;=122) or (ord(i)\u0026gt;=65 and ord(i)\u0026lt;=90): count_a=count_a+1 elif ord(i)\u0026gt;=48 and ord(i)\u0026lt;=57: count_z=count_z+1 elif ord(i)==32: count_s=count_s+1 else: count_o=count_o+1 print(\u0026#34;空格个数：%d个\u0026#34;%count_s) print(\u0026#34;数字个数：%d个\u0026#34;%count_z) print(\u0026#34;英文字母个数：%d个\u0026#34;%count_a) print(\u0026#34;其他字符个数：%d个\u0026#34;%count_o) str_count(\u0026#34;我是wei guo ying,今年27岁\u0026#34;)   创建一个函数，可以将去除给定列表中中相邻且重复的元素(只保留一个)后，打印输出结果。  说明  输入参数为 l1=[1,2,3,4,4,4,4,4,4,5,6,6,8,8,12,12,12,12,13] 操作后，保证原有整体排序不变，仅处理相邻且重复的元素 请勿使用set，否则该题不计分。    1 2 3 4 5 6 7 8 9 10 11 12 13  def remove_same(ll): cur = ll[0] remove_data = [] for i in range(1,len(ll)): if cur == ll[i]: remove_data.append(ll[i]) else: cur = ll[i] for j in range(len(remove_data)): ll.remove(remove_data[j]) return ll lst=[1,2,3,4,4,4,4,4,4,5,6,6,8,8,12,12,12,12,13] print(remove_same(lst))   创建一个函数，接收一个由整数组成的列表（需对输入列表做检查，长度最少为2,数据类型为整型），并检验后下列条件后输出：  如列表是升序排列的,则输出\u0026quot;ASC\u0026rdquo;; 如列表是降序排列的,则输出\u0026quot;DESC\u0026rdquo;; 如列表无序，则输出\u0026quot;WRONG\u0026rdquo;。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  def check_data(l): if len(l) \u0026lt; 2: print(\u0026#39;您输入的列表长度小于2，请重新输入\u0026#39;) else: check_list = list(filter(lambda x : True if isinstance(x,int) else False,l)) if len(l) == len(check_list): if l == sorted(l): print(\u0026#39;ASC\u0026#39;) elif l == sorted(l,reverse = True): print(\u0026#39;DESC\u0026#39;) else: print(\u0026#39;WRONG\u0026#39;) else: print(\u0026#34;列表中数据类型包含非整型，请重新输入\u0026#34;) check_data([1]) check_data([1,\u0026#34;2\u0026#34;]) check_data([1,2,3,4]) check_data([4,3,2,1]) check_data([1,3,2,4])   高阶函数综合运用 l1=[1,3,6,8,10,11,17]\n请仅使用map,reduce,filter对上方数组依次进行如下三次操作：\n 剔除掉所有的偶数后打印 对剩下的数字每个数字进行平方后打印 对数组求和后打印\n注意：每一题都是在上一问的基础上操作  1 2 3 4 5 6 7 8 9 10 11 12 13  #剔除掉所有的偶数后打印 l1 = [1,3,6,8,10,11,17] l2 = list(filter(lambda x:True if x%2 == 1 else False,l1)) print(l2) #对剩下的数字每个数字进行平方后打印 l3 = list(map(lambda x:pow(x,2),l2)) print(l3) #对数组求和后打印 from functools import reduce l4 = reduce(lambda x,y : x+y,l3) print(l4)   Python类设计 设计一个公司类，完成以下要求，并实例化不同对象进行验证\n类变量\n 类下公司的总个数，类下公司实例的名称列表\n类方法 返回公司类共有多少个公司实例 返回公司类的公司实例有名称列表\n实例变量 公司名，简介，利润，销售额，总成本，雇员姓名列表，雇员详细信息列表(这里可能会考察到*号对参数解包)\n实例方法： 招聘人才（每招一个人会有成本产生，影响该实例雇员列表、人数、总成本，默认成本cost=10000） 解雇人员（每解雇一个人会有成本产生，影响该实例雇员列表、人数 、总成本，默认成本cost=5000） 公司广告推广(影响该实例总成本，自定义成本cost) 交社保(按公司雇员总人数计算，影响该实例总成本，默认单人社保缴纳1000) 交税(按公司雇员总人数计算，影响该实例总成本，默认单人税费缴纳500) 销售（按销售件数*价格计算销售额，利润按销售额*利润率进行计算利润。默认利润率50%） 获取公司雇员列表 获取公司净利润  提示：具体的函数方法与变量定义，请参考下述实例化代码确定。初始化雇员的地方，大家看到调用的时候会包含年龄等信息，这里可能会用到不定长参数输入，详细可以参考python参数说明\n提示：写不出来的同学可以看一下上方的说明，实际上代码的结构跟上方说明结构基本一致\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  class Company(): companyNum = 0 companyList = [] def __init__(self, companyName, profile): self.companyName = companyName self.profile = profile self.profit = 0 self.sales = 0 self.totalCost = 0 self.employeeNames = [] self.employeeList = [] Company.companyNum += 1 Company.companyList.append(companyName) def recruit(self, name, *args, cost=10000): self.employeeNames.append(name) self.employeeList.append((name,*args)) self.totalCost += cost def dismiss(self, name, cost=5000): try: self.employeeNames.remove(name) for index in range(len(self.employeeList)): if self.employeeList[index][0]==name: self.employeeList.pop(index) self.totalCost += cost except ValueError: print(\u0026#39;没有name={}的员工，请重试\u0026#39;.format(name)) def adPromotion(self, cost): self.totalCost += cost def payInsurance(self, costPerPerson=1000): self.totalCost += costPerPerson * len(self.employeeNames) def payTax(self, costPerPerson=500): self.totalCost += costPerPerson * len(self.employeeNames) def sale(self, num, price, profit=0.5): self.sales += num * price self.profit += self.sales * profit def getEmployeeList(self): return self.employeeList def getProfit(self): return self.profit @classmethod def getCompanyNum(cls): return len(cls.companyList) @classmethod def getCompanyList(cls): return cls.companyList   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  #功能验证 c0 = Company(\u0026#39;小象学院\u0026#39;,\u0026#39;大数据AI在线教育\u0026#39;) c0.recruit(\u0026#39;HanXiaoyang\u0026#39;,18, cost=20000) c0.recruit(\u0026#39;Eric\u0026#39;,20, cost=10000) print(\u0026#39;{}公司员工详细信息列表:{}\u0026#39;.format(c0.companyName,c0.getEmployeeList())) c0.dismiss(\u0026#39;Eric\u0026#39;) c0.adPromotion(5000) c0.payInsurance() c0.payTax() c0.sale(50,100) print(\u0026#39;{}公司员工详细信息列表:{}\u0026#39;.format(c0.companyName,c0.getEmployeeList())) print(\u0026#39;{}公司当前利润：{}\u0026#39;.format(c0.companyName,c0.getProfit())) c1 = Company(\u0026#39;百度\u0026#39;,\u0026#39;搜索引擎\u0026#39;) c1.recruit(\u0026#39;liyanhong\u0026#39;,30, cost=50000) c1.recruit(\u0026#39;likaifu\u0026#39;,50, cost=40000) print(\u0026#39;{}公司员工详细信息列表:{}\u0026#39;.format(c1.companyName,c1.getEmployeeList())) print(\u0026#39;公司名列表：\u0026#39;,Company.companyList) print(\u0026#39;公司总个数：\u0026#39;,Company.companyNum)   结合PIL库，制作一个能生成5位随机数验证码图片的函数。 生成5位随机数验证码并存储为verify.png名称的图片。\n提示：PIL库的使用方法可以参考python中PIL库的使用和PIL库简易教程与验证码生成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  %matplotlib inline from PIL import Image from PIL import ImageDraw from PIL import ImageFont import random def getRandomColor(): \u0026#39;\u0026#39;\u0026#39;获取一个随机颜色(r,g,b)格式的\u0026#39;\u0026#39;\u0026#39; c1 = random.randint(0,255) c2 = random.randint(0,255) c3 = random.randint(0,255) return (c1,c2,c3) # 获取一个Image对象，参数分别是RGB模式。宽150，高30，随机颜色 image = Image.new(\u0026#39;RGB\u0026#39;,(150,30),getRandomColor()) # 获取一个画笔对象，将图片对象传过去 draw = ImageDraw.Draw(image) # 获取一个font字体对象参数是ttf的字体文件的目录，以及字体的大小 font = ImageFont.truetype(\u0026#34;arial.ttf\u0026#34;, size=22) for i in range(5): # 循环5次，获取5个随机字符串 random_char = str(random.randint(0, 9)) print(random_char) # 在图片上一次写入得到的随机字符串,参数是：定位，字符串，颜色，字体 draw.text((10+i*30, 4),random_char,getRandomColor(),font) # 噪点噪线 width=180 height=30 # 划线 for i in range(5): x1=random.randint(0,width) x2=random.randint(0,width) y1=random.randint(0,height) y2=random.randint(0,height) draw.line((x1,y1,x2,y2),fill=getRandomColor()) # 画点 for i in range(30): draw.point([random.randint(0, width), random.randint(0, height)], fill=getRandomColor()) x = random.randint(0, width) y = random.randint(0, height) draw.arc((x, y, x + 5, y + 5), 0, 90, fill=getRandomColor()) # 保存到硬盘，名为verify.png格式为png的图片 image.save(open(\u0026#39;verify.png\u0026#39;, \u0026#39;wb\u0026#39;), \u0026#39;png\u0026#39;)    0\n4\n2\n1\n0\n 1 2 3 4 5 6 7 8  %matplotlib inline import matplotlib.pyplot as plt img = Image.open(\u0026#39;verify.png\u0026#39;) plt.figure(\u0026#39;\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.imshow(img) # %%html # \u0026lt;img src=\u0026#34;verify.png\u0026#34; width=\u0026#34;40%\u0026#34;\u0026gt;   "
},
{
	"uri": "https://lczen.github.io/en/showcase/hugo/",
	"title": "Hugo",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Hugo theme collection",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/showcase/",
	"title": "Showcase overview",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "My portfolio, repos, works overview page",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/categories/python%E5%9F%BA%E7%A1%80/",
	"title": "python基础",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/basicpractice/",
	"title": "python小练习",
	"tags": ["练习题"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "指定str位置，并更改该位置的值 1.实现一个功能，用户输入一个字符串，修改字符串中哪个位置，程序就会输出修改后的结果。（输入用input函数） 比如输入： 'fkjava.ipg' 6 - 程序输出：'fkjana-ipg' 我的理解：str不能根据index改变对应位置的值，而list可以。list转换成str用str的join函数。 1 2 3 4 5 6 7 8  s = input(\u0026#39;请输入一个字符串：\u0026#39;) k = input(\u0026#39;请输入要修改的位置和要修改成的符号，用空格分开：\u0026#39;) num = int(k[0]) # 要修改的index sub = k[2] # 要替换的字符 list_s = list(s) # 因为字符串是不可变的数据类型，我们字符串变成列表 list_s[num] = sub # 替换对应位置的字符 s = \u0026#39;\u0026#39;.join(list_s) print(\u0026#39;结果是：\u0026#39;, s)   找子串的数量 2.用户输入一个字符串和一个子串，程序会输出给定的子串在目标字符串中出现的次数。字符串遍历从左到右，而不是从右到左。 例如给定 'ABCDCDC' 和 'CDC' ，程序输出 '2' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #法一，利用str的find方法 s = input(\u0026#39;输入字符串\u0026#39;) sub_s = input(\u0026#39;输入子字符串\u0026#39;) index = 0 count = 0 for i in range(len(s)+1): if s.find(sub_s,index) != -1: count += 1 index = s.find(sub_s,s.find(sub_s,index)+1) print(count) #法二：关键点，s[i:i+len_ss] == ss s = input(\u0026#39;请输入一个字符串：\u0026#39;) ss = input(\u0026#39;请输入要查找的字串：\u0026#39;) num = 0 # 创建最后输出用的变量 len_ss = len(ss) # 我们的思路是通过切片来取出 s 中的一部分判断是否和子串 ss 一致，所以这里要先知道 ss 的长度 for i in range(len(s) - len_ss + 1): # 防止后面做切片的时候索引超出上界，这里我们先减掉 ss 的长度，最后一位数不被包括，所以 +1 if s[i] == ss[0]: # 判断每个字符和 ss 开头字符是否匹配 if s[i:i+len_ss] == ss: # 判断接下来的 len_ss 长度的字符是否与 ss 一致 num += 1 print(num)   把输入数据封装成元祖 3.提示用户输入N个字符串（N自己定义），将他们封装成元组，然后计算该元组乘以3再加上（'hello','world'）的结果。 keypoint:列表可以强转换成元组，元组+元组=元组 1 2 3 4 5  s = input(\u0026#39;请输入一些字符串，用空格隔开：\u0026#39;) list_s = s.split(\u0026#39;\u0026#39;) tuple_s = tuple(list_s) result = tuple_s * 3 + (\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;) print(result) # 主要观察结果的呈现形式，重点理解 元组 * 数字 的含义以及元组之间加法的用法   请输入一些字符串，用空格隔开：w ('w', 'w', 'w', 'hello', 'world') 列表append随机数 4.用户输入一个整数n，生成长度为n的列表，并将n个随机数放入列表中。（随机数可以参考random库，百度搜索 python random 即可） 1 2 3 4 5  num = int(input(\u0026#39;请用户输入一个整数：\u0026#39;))# 这里要注意input函数返回的是字符串类型，需要转成整型 l = [] # 定义一个空列表，用来装后面生成的随机数 for i in range(num): # 循环n次 l.append(r.random()) # 这里数字范围不限，可以用random库里不同的函数来实现 print(l)   将n个随机的奇数放入列表 5.用户输入一个整数n，生成长度为n的列表，并将n个随机的奇数放入列表中。 1 2 3 4 5 6 7 8 9  num = int(input(\u0026#39;请用户输入一个整数：\u0026#39;)) l = [0] * num # 这道题我们换一个思路，先生成列表，用0站位，然后我们替换里面的数字 for i in range(num): # 遍历l，对每个0做替换 while True: # while True 为死循环，当满足条件时我们用break打破循环 n = r.randint(1, 100) # 生成1-100之间的随机整数 if n%2 == 1: l[i] = n break print(l)   choice 6.用户输入一个整数n，生成长度为n的列表，并将n个随机的大写字符放入列表中。 1 2 3 4 5  num = int(input(\u0026#39;请用户输入一个整数：\u0026#39;)) l = [] for i in range(num): l.append(r.choice(\u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39;).upper()) # 用upper()变成大写，可以思考还有其他生成随机字符的方式吗？ print(l)   输出整数的最大值 7.用户输入以空格分隔的多个整数，输出这些整数的最大值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #法一 list.sort 列表表达式 nums = input(\u0026#39;请输入一些整数，以空格分隔：\u0026#39;) list_nums = nums.split(\u0026#39;\u0026#39;) list_int_nums = [int(item) for item in list_nums] list_int_nums.sort() print(list_int_nums[len(list_int_nums)-1]) #法二 nums = input(\u0026#39;请输入一些整数，以空格分隔：\u0026#39;) list_nums = nums.split(\u0026#39;\u0026#39;) list_int_nums = [] for i in range(len(list_nums)): # 第一个循环，我们把所有数字从字符串变成整型 num = int(list_nums[i]) list_int_nums.append(num) a = -99999999 for i in list_int_nums: # 第二个循环，a为目前最大数，遍历列表，如果当前数字比a大，把当前值赋值给a if i \u0026gt; a: a = i print(\u0026#39;最大的数为：\u0026#39;, a)   统计字符串中每个字母的次数* 8.用户输入N个大写字母，使用dict统计用户输入的每个字母的次数。 1 2 3 4 5 6 7 8  s = input(\u0026#39;请输入一些大写字母：\u0026#39;) d = dict() for i in s: if i in d.keys(): d[i] += 1 else: d[i] = 1 print(d)   输出等腰三角形 9.使用循环输出等腰三角形，层数由用户输入（input），输出结果如下（输入3）： * * *** keypoint:用数学方式去理解，*的规律是2n-1 1 2 3  n = int(input(\u0026#39;请输入三角形的层数：\u0026#39;)) for i in range(1, n+1): print((n-i)*\u0026#39;\u0026#39; + (2*i-1)*\u0026#39;*\u0026#39; + (n-i)*\u0026#39;\u0026#39;)   请输入三角形的层数：3 * *** ***** 九九乘法表 10.使用循环输出九九乘法表。输入结果如下： 1 * 1 = 1 1 * 2 = 2 2 * 2 = 4 ....... 1 2 3 4  for i in range(1, 10): for j in range(1, i+1): print(\u0026#39;{}x{}={}\\t\u0026#39;.format(j, i, i*j), end=\u0026#39;\u0026#39;) # \\t为制表符 print()   1x1=1\t1x2=2\t2x2=4\t1x3=3\t2x3=6\t3x3=9\t1x4=4\t2x4=8\t3x4=12\t4x4=16\t1x5=5\t2x5=10\t3x5=15\t4x5=20\t5x5=25\t1x6=6\t2x6=12\t3x6=18\t4x6=24\t5x6=30\t6x6=36\t1x7=7\t2x7=14\t3x7=21\t4x7=28\t5x7=35\t6x7=42\t7x7=49\t1x8=8\t2x8=16\t3x8=24\t4x8=32\t5x8=40\t6x8=48\t7x8=56\t8x8=64\t1x9=9\t2x9=18\t3x9=27\t4x9=36\t5x9=45\t6x9=54\t7x9=63\t8x9=72\t9x9=81\t"
},
{
	"uri": "https://lczen.github.io/en/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/",
	"title": "练习题",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/regular/",
	"title": "Regular",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "正则表达式 re模块 学习网站：http://regexr.com/\nPython通过re模块提供对正则表达式的支持。\n使用re的一般步骤是\n 1.将正则表达式的字符串形式编译为Pattern实例 2.使用Pattern实例处理文本并获得匹配结果（一个Match实例） 3.使用Match实例获得信息，进行其他的操作。  1 2 3 4 5 6 7 8 9 10 11 12  # encoding: UTF-8 import re # 将正则表达式编译成Pattern对象 pattern = re.compile(r\u0026#39;hello.*\\!\u0026#39;) # 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None match = pattern.match(\u0026#39;hello, hanxiaoyang! How are you?\u0026#39;) if match: # 使用Match获得分组信息 print(match.group())   re.compile(strPattern[, flag]):\n这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。\n第二个参数flag是匹配模式，取值可以使用按位或运算符'|'表示同时生效，比如re.I | re.M。\n当然，你也可以在regex字符串中指定模式，比如re.compile(\u0026lsquo;pattern\u0026rsquo;, re.I | re.M)等价于re.compile('(?im)pattern\u0026rsquo;)\nflag可选值有：\n re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同） re.M(MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图） re.S(DOTALL): 点任意匹配模式，改变\u0026rsquo;.\u0026lsquo;的行为 re.L(LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 re.U(UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 re.X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：  1 2 3 4  regex_1 = re.compile(r\u0026#34;\u0026#34;\u0026#34;\\d + # 数字部分\\. # 小数点部分\\d * # 小数的数字部分\u0026#34;\u0026#34;\u0026#34;, re.X) regex_2 = re.compile(r\u0026#34;\\d+\\.\\d*\u0026#34;)   Match 小象学院《机器学习集训营》课程资料 by @寒小阳\nMatch对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。\nmatch属性：\n string: 匹配时使用的文本。 re: 匹配时使用的Pattern对象。 pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。 lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。  match方法：\n group([group1, …]): 获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 groups([default]): 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 groupdict([default]): 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。 start([group]): 返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。 end([group]): 返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。 span([group]): 返回(start(group), end(group))。 expand(template): 将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符'0\u0026rsquo;，只能使用\\g\u0026lt;1\u0026gt;0。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import re m = re.match(r\u0026#39;(\\w+) (\\w+)(?P\u0026lt;sign\u0026gt;.*)\u0026#39;, \u0026#39;hello hanxiaoyang!\u0026#39;)#?P\u0026lt;sign\u0026gt;.*是标点的意思 print \u0026#34;m.string:\u0026#34;, m.string print \u0026#34;m.re:\u0026#34;, m.re print \u0026#34;m.pos:\u0026#34;, m.pos print \u0026#34;m.endpos:\u0026#34;, m.endpos print \u0026#34;m.lastindex:\u0026#34;, m.lastindex print \u0026#34;m.lastgroup:\u0026#34;, m.lastgroup print \u0026#34;m.group(1,2):\u0026#34;, m.group(1, 2) print \u0026#34;m.groups():\u0026#34;, m.groups() print \u0026#34;m.groupdict():\u0026#34;, m.groupdict() print \u0026#34;m.start(2):\u0026#34;, m.start(2) print \u0026#34;m.end(2):\u0026#34;, m.end(2) print \u0026#34;m.span(2):\u0026#34;, m.span(2) print r\u0026#34;m.expand(r\u0026#39;\\2 \\1\\3\u0026#39;):\u0026#34;, m.expand(r\u0026#39;\\2 \\1\\3\u0026#39;)   m.string: hello hanxiaoyang! m.re: \u0026lt;_sre.SRE_Pattern object at 0x10b111be0\u0026gt; m.pos: 0 m.endpos: 18 m.lastindex: 3 m.lastgroup: sign m.group(1,2): ('hello', 'hanxiaoyang') m.groups(): ('hello', 'hanxiaoyang', '!') m.groupdict(): {'sign': '!'} m.start(2): 6 m.end(2): 17 m.span(2): (6, 17) m.expand(r'\\2 \\1\\3'): hanxiaoyang hello! Pattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。 Pattern不能直接实例化，必须使用re.compile()进行构造。 Pattern提供了几个可读属性用于获取表达式的相关信息： * pattern: 编译时用的表达式字符串。 * flags: 编译时用的匹配模式。数字形式。 * groups: 表达式中分组的数量。 * groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。 1 2 3 4 5 6 7  import re p = re.compile(r\u0026#39;(\\w+) (\\w+)(?P\u0026lt;sign\u0026gt;.*)\u0026#39;, re.DOTALL) print \u0026#34;p.pattern:\u0026#34;, p.pattern print \u0026#34;p.flags:\u0026#34;, p.flags print \u0026#34;p.groups:\u0026#34;, p.groups print \u0026#34;p.groupindex:\u0026#34;, p.groupindex   p.pattern: (\\w+) (\\w+)(?P\u0026lt;sign\u0026gt;.*) p.flags: 16 p.groups: 3 p.groupindex: {'sign': 3} pattern匹配与替换  match(string[, pos[, endpos]]) | re.match(pattern, string[, flags]): 这个方法将从string的pos下标处起尝试匹配pattern:  如果pattern结束时仍可匹配，则返回一个Match对象 如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。 pos和endpos的默认值分别为0和len(string)。 **注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符'$\u0026rsquo;。 **   search(string[, pos[, endpos]]) | re.search(pattern, string[, flags]): 这个方法从string的pos下标处起尝试匹配pattern  如果pattern结束时仍可匹配，则返回一个Match对象 若无法匹配，则将pos加1后重新尝试匹配，直到pos=endpos时仍无法匹配则返回None。 pos和endpos的默认值分别为0和len(string))    1 2 3 4 5 6 7 8 9 10 11 12 13  # encoding: UTF-8  import re # 将正则表达式编译成Pattern对象  pattern = re.compile(r\u0026#39;H.*g\u0026#39;) # 使用search()查找匹配的子串，不存在能匹配的子串时将返回None  # 这个例子中使用match()无法成功匹配  match = pattern.search(\u0026#39;hello Hanxiaoyang!\u0026#39;) if match: # 使用Match获得分组信息  print match.group()#Hanxiaoyang    split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]):  按照能够匹配的子串将string分割后返回列表。 maxsplit用于指定最大分割次数，不指定将全部分割。    1 2 3 4  import re p = re.compile(r\u0026#39;\\d+\u0026#39;) print p.split(\u0026#39;one12306two2three3four4\u0026#39;)   ['one', 'two', 'three', 'four', '']  findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags]):  搜索string，以列表形式返回全部能匹配的子串。    1 2 3 4  import re p = re.compile(r\u0026#39;\\d+\u0026#39;) print p.findall(\u0026#39;one12306two2three3four4\u0026#39;)   ['12306', '2', '3', '4']  **finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags]): **  搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。    1 2 3 4 5  import re p = re.compile(r\u0026#39;\\d+\u0026#39;) for m in p.finditer(\u0026#39;one1two2three3four4\u0026#39;): print m.group()   1 2 3 4  **sub(repl, string[, count]) | re.sub(pattern, repl, string[, count]): **  使用repl替换string中每一个匹配的子串后返回替换后的字符串。  当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。 当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。\ncount用于指定最多替换次数，不指定时全部替换。      1 2 3 4 5 6 7 8 9 10 11  import re p = re.compile(r\u0026#39;(\\w+) (\\w+)\u0026#39;) s = \u0026#39;i say, hello hanxiaoyang!\u0026#39; print p.sub(r\u0026#39;\\2 \\1\u0026#39;, s) def func(m): return m.group(1).title() + \u0026#39;\u0026#39; + m.group(2).title() print p.sub(func, s)   say i, hanxiaoyang hello! I Say, Hello Hanxiaoyang!  **subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]): **  返回 (sub(repl, string[, count]), 替换次数)。    import re p = re.compile(r'(\\w+) (\\w+)') s = 'i say, hello hanxiaoyang!' print p.subn(r'\\2 \\1', s) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print p.subn(func, s) ('say i, hanxiaoyang hello!', 2) ('I Say, Hello Hanxiaoyang!', 2) "
},
{
	"uri": "https://lczen.github.io/en/posts/python/",
	"title": "Python学习",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "Python基础 Python运行方式 解释运行 新建py文件，直接运行\n1 2  %%writefile print_str.py print(\u0026#34;欢迎大家学习课程内容！\u0026#34;)   交互运行 ipython, notebook\nPython标识符 1 2 3 4  #如以下标识符取名错误 for=\u0026#39;chinahadoop.cn\u0026#39; 7a=8 str=\u0026#39;小象学院\u0026#39;   好的命名习惯   变量，函数或方法:salary,houseworker,booksname 常量：INTEREST_RATES 类：BankAccount,Employee,Company,OrderedDict #骆峰命名法   操作符优先级 第1名 - 函数调用、寻址、下标 第2名 - 幂运算 ** 第3名 - 翻转运算符 ~ 第4名 - 正负号 第5名 - *、/、% 第6名 - +、- 取商运算和开方 a//b #取商\na**0.5 #开方\n7.in和not in操作适用于str 1 2 3  websiteUrl=\u0026#39;chinahadoop.cn\u0026#39; if \u0026#39;.net\u0026#39; not in websiteUrl: print (\u0026#39;.net not in it\u0026#39;)   8.赋值操作 1 2 3  a=b=100 a,b,c=100,200,200 a,b=b,a#交换赋值   基本数据类型与数据结构 基本数据类型 类型：\nnumber：\nint,float,complex\nboolean,String,List,Tuple,Dictionary\n类型转换：\nint(a),str(a),eval(x),tuple(x),list(x),chr(x) # 整数转换为字符\n数值型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #进制转换 a=0b0101001#bin() b=0o4#oct() c=0x28#hex() #浮点型 pi=3.1415 #科学计算法 c=5e13 print(c) #数字的正负无穷 #float(\u0026#39;inf\u0026#39;)正无穷 #float(\u0026#39;-inf\u0026#39;)负无穷 if 99999999999999999\u0026lt;float(\u0026#39;inf\u0026#39;): print(\u0026#39;you win!\u0026#39;) #复数 a=4.3+22j type(a) #数值类型转换 a=4.48 b=8 int(a) # 保留n位小数四舍五入 round(pi,3)   字符串型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  str2=\u0026#39;chinahadoop.cn\u0026#39; #str2[start🔚stride] #切片访问的特点：左闭右开[) str2[0::2] #从index为0到结尾，每隔2-1=1个字符取一次 #格式化访问1 companyName=\u0026#39;chinahadoop\u0026#39; str3=\u0026#39;http://{}.cn\u0026#39; print(str3.format(companyName)) #格式化访问2 print(\u0026#34;Company name is %s\u0026#34; %companyName) #格式化访问3 _=\u0026#39;Python 3.6\u0026#39;#fstring only can be used under version 3.6 str4=f\u0026#34;fstring is new feature of {_}\u0026#34; str4 #查找与替换 str3.find(\u0026#39;o\u0026#39;) str3.replace(\u0026#39;.cn\u0026#39;,\u0026#39;.net\u0026#39;) #统计 str3.count(\u0026#39;cn\u0026#39;)   数据结构 列表list 列表[]:任意元素类型对象的序列\n1 2 3 4 5 6 7 8 9  #append和extend # 列表追加 l2.append([\u0026#39;last\u0026#39;, \u0026#39;elem\u0026#39;]) #追加1个元素，这个元素是列表 l2.extend([\u0026#39;new\u0026#39;, \u0026#39;item\u0026#39;]) #追加列表 l2 + l1 #追加列表 # 列表删除元素 l2.pop() #返回最尾部元素，并删除该元素 l2.remove(\u0026#39;china\u0026#39;) #移除列表中的某个值的第一个匹配项，没有返回值   1 2 3 4 5  # 字符串列表的拼接与分割 l3 = [\u0026#39;I\u0026#39;, \u0026#39;love\u0026#39;, \u0026#39;China\u0026#39;] \u0026#34;_\u0026#34;.join(l3) #用下划线拼接列表元素(需要是字符串) a = \u0026#34;#\u0026#34;.join(l3) a.split(\u0026#34;#\u0026#34;) #用井号切分字符串生成列表   1 2 3 4 5 6 7 8 9 10 11 12 13  # 列表排序 my_list = [5,1,2,4,3] my_list.sort() #对my_list排序，直接改变my_list new_list = [5,1,2,4,3] sorted(new_list) #对new_list排序，以返回值返回排序结果，并不改变new_list # sorted高级用法 tmp_strs = [\u0026#39;aa\u0026#39;, \u0026#39;BBc\u0026#39;, \u0026#39;CCdd\u0026#39;, \u0026#39;zzmm\u0026#39;] sorted(tmp_strs) #按照字母序排序 sorted(tmp_strs, reverse=True) #按照字母序降序排序 sorted(tmp_strs, key=len) #根据key对元素做处理后的结果对原序列排序，这里的len是函数，返回字符串长度 sorted(tmp_strs, key=str.lower) #根据小写后的结果字母序排序 sorted(word_dic.items(), key=lambda d: d[1], reverse=True)#字典按照value排序   元组tuple 1 2 3 4 5 6 7 8 9  #元组()tuple,只读列表 t1=(1,2,3,4) #只读列表是真的只读吗？ t2=(1,2,3,[4,5,6]) t2[0]=11#报错 tup = (\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000) tup1 = (50,) #元组中只包含一个元素时，需要在元素后面添加逗号 tup[1:] #元组的切片拼接和list一样   集合set(去重非常好用) 1 2 3 4  #集合{}set：无序的不重复元素,集合中的对象，通常叫key s1={1,1,1,2,3,4,5,2,4,234} l2=[1,1,1,2,3,4,5,2,4,234] set(l2)   字典 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # 字典是另一种可变容器模型，且可存储任意类型对象。 # 字典的每个键值 key=\u0026gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 my_dict = {\u0026#39;HanXiaoyang\u0026#39;: 1234, \u0026#39;Jason\u0026#39;: 4567, \u0026#39;David\u0026#39;: 6789} #定义字典 ks = my_dict.keys() #取出所有的key vs = my_dict.values() #取出所有的values Hv = my_dict[\u0026#39;HanXiaoyang\u0026#39;] #根据key取对应的value Dv = my_dict.get(\u0026#39;XiaoMing\u0026#39;, 2345) #根据key去取value，如果key不存在返回默认值 my_dict[\u0026#39;HanXiaoyang\u0026#39;] = 7890 #改变字典中key对应的value值 flag = \u0026#39;DaDa\u0026#39; in my_dict #判断是否有某个key # 遍历字典元素 for key in my_dict: print(key,my_dict[key]) from collections import OrderedDict # 注意，字典是一种键值对数据结构，本身是无序的，如果需要顺序，可以用OrderedDict od1=OrderedDict()#按主键首次插入顺序进行排序 od1[\u0026#39;a\u0026#39;]=7 od1[\u0026#39;z\u0026#39;]=8 od1[\u0026#39;b\u0026#39;]=9   声明Statement与Expression表达式 1 2 3 4 5 6 7 8 9 10 11  #statement声明 a=\u0026#39;小象学院\u0026#39;#statement通常为赋值语句 b=100 c=a #Expression表达式 #值、变量和运算符共同组成的整体我们将其称为表达式。通常有值表达式、变量表达式、计算表达式、字符串表达式, b,b+100,a+\u0026#39;is amazing\u0026#39;,__builtins__ #exec执行声明语句,eval执行表达式 exec(\u0026#39;a=5\u0026#39;) b=3 eval(\u0026#39;a+b+5\u0026#39;)   判断：if， if else ,if elif elif与三元表达式 1  \u0026#39;a\u0026#39; if age\u0026gt;50 else \u0026#39;b\u0026#39;   列表推导式List Comprehensions，可迭代对象Iterable与迭代器iterator,生成器generator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #列表推导式：从一个列表中生成一个新的列表，简化了循环的写法 l1= [x+1 for x in range(30) if x%3==0] #新的list中的元素，来源于从0-29这个list中所有整除3的元素+1 l1=[0, 3, 6, 9, 12, 15, 18, 21, 24, 27] l2=iter(l1) l2.__next__() #可迭代对象Iterable：可以被for循环的对象统称为可迭代对象Iterable,list,str,dict这些都是可迭代类型 #迭代器Iterator：可以被next调用的迭代器。 #next(l1) #TypeError: \u0026#39;list\u0026#39; object is not an iterator #使用iter将一来个可迭代对象变为迭代器 l1=iter(l1) next(l1),next(l1) #生成器Generator：首先是一个迭代器，然后其内容是按需生成 #列表是一次性生成，缺点是当内容过大时会占用大量内容，那能不能用到多少生成多少呢？ #Python里一边循环一边计算(惰性计算)的迭代器称为生成器（Generator） #1.直接从列表表达式生成 g1= (x**2 for x in range(30) if x%2==0) type(g1) #\u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; next(g1),next(g1),next(g1),next(g1),g1.__next__(),g1.__next__() #2.函数生成，与yield关键字 def g2_func(n): for i in range(n): yield i**2 g2=g2_func(7) next(g2),next(g2),g2.__next__(),g2.__next__(),g2.__next__(),g2.__next__() #yield from/子迭代器，后面直接是可迭代对象。 def yield_from_iter(iter_object): yield from iter_object y1=yield_from_iter(\u0026#39;China\u0026#39;) y1.__next__(),next(y1)   处理异常 1 2 3 4 5 6 7 8 9 10 11 12  #try-finally 无法是否捕获了异常，都会执行finally后的语句 x = 5 #y = 2 y = 0 try: result = x / y except ZeroDivisionError: print(\u0026#34;division by zero!\u0026#34;) else: print(\u0026#34;result is\u0026#34;, result) finally: print(\u0026#34;executing finally clause\u0026#34;)   函数定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  # 定义斐波那契数列 def fib(n): a, b =1, 1 for i in range(n): print(a, end=\u0026#34;\u0026#34;) a,b = b,a+b print() # 函数默认参数 def printinfo(name, age = 35): print(\u0026#34;姓名:\u0026#34;, name) print(\u0026#34;年龄:\u0026#34;, age) return #调用printinfo函数 printinfo(age=50, name=\u0026#34;隔壁老王\u0026#34;); printinfo(name=\u0026#34;隔壁老王\u0026#34;); def printinfo(arg1, *vartuple): \u0026#34;打印任何传入的参数\u0026#34; print(\u0026#34;输出:\u0026#34;) print(arg1) print(vartuple) return # 调用printinfo 函数 printinfo(10) printinfo(70, 60, 50) # python 使用 lambda 来创建匿名函数。lambda [arg1,arg2,.....argn]:expression sum = lambda arg1, arg2: arg1 + arg2; # 调用sum函数 print(\u0026#34;相加后的值为:\u0026#34;, sum( 10, 20 )) print(\u0026#34;相加后的值为:\u0026#34;, sum( 20, 30 ))   filter和map和reduce 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。 #判断是否为正数 def is_positive(x): return x \u0026gt; 0 result = filter(is_positive,[1,3,5,-1,-10,0]) list(result) #map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 ## 每个元素求平方 def f(x): return x * x result = map(f,[1,3,5,-1,-10,0]) list(result) #reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。 from functools import reduce ## 求和 def add(x,y): return x + y result = reduce(add,[1,3,5,-1,-10,0])   counter函数 1  word_dic = dict(collections.Counter(words_box))#统计列表words_box中词频并转成字典   文件操作 文件读 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # 要以读文件的模式打开一个文件对象，使用Python内置的`open()`函数，传入文件名和标示符： f = open(\u0026#39;print_str.py\u0026#39;, \u0026#39;r\u0026#39;) # 如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示： f.read() # 最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源 f.close() # 异常处理模式 try: f = open(\u0026#39;/path/to/file\u0026#39;, \u0026#39;r\u0026#39;) print(f.read()) except Exception as e: print e finally: if f: f.close() # 逐行读取 with open(\u0026#39;test.py\u0026#39;, \u0026#39;r\u0026#39;) as f: for line in f.readlines(): print(line.strip())   文件写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  with open(\u0026#39;test.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;Hello, world!\\n\u0026#39;) f.write(\u0026#39;new line\u0026#39;) lines = [\u0026#39;Hello, python!\\n\u0026#39;, \u0026#39;New text!\u0026#39;] with open(\u0026#39;new.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.writelines(lines) # 需要用到os内置模块 import os # 列举当前绝对路径 os.path.abspath(\u0026#39;.\u0026#39;) # 新建文件夹 os.mkdir(\u0026#39;./testdir\u0026#39;) # 文件重命名 os.rename(\u0026#39;test.txt\u0026#39;, \u0026#39;test2.txt\u0026#39;) # 列出当前路径下的所有文件夹 [x for x in os.listdir(\u0026#39;.\u0026#39;) if os.path.isdir(x)] # 列出当前路径下的所有python脚本文件 [x for x in os.listdir(\u0026#39;.\u0026#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==\u0026#39;.py\u0026#39;]   面向对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 类的设计与创建 # 使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾，类的主体由类成员，方法，数据属性组成 class Employee: \u0026#34;所有员工的基类\u0026#34; empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print(\u0026#34;总共雇员数量 %d\u0026#34; % Employee.empCount) def displayEmployee(self): print(\u0026#34;姓名: \u0026#34;, self.name, \u0026#34;, 工资: \u0026#34;, self.salary) # empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。 # 第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法 # self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。 # 创建对象 \u0026#34;创建 Employee 类的第一个对象\u0026#34; emp1 = Employee(\u0026#34;张三\u0026#34;, 2000) \u0026#34;创建 Employee 类的第二个对象\u0026#34; emp2 = Employee(\u0026#34;李四\u0026#34;, 5000) # 调用成员函数 emp1.displayEmployee() emp2.displayEmployee() print(\u0026#34;总共雇员数%d\u0026#34; % Employee.empCount)   "
},
{
	"uri": "https://lczen.github.io/en/posts/jupyter%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/",
	"title": "jupyter小技巧",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "1.jupyter安装 1 2 3 4  conda install jupyter notebook # 安装anaconda之后，下载jupyter notebook conda install -c conda-forge jupyter_contrib_nbextensions # jupyter notebook扩展安装 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple autopep8 # 代码自动规范化包   2.jupyter magic关键字 %quickref %lsmagic #查看magic有哪些magic命令 #line magic %config ZMQInteractiveShell.ast_node_interactivity='all'#这里是打印多行的开关 off打印多行 %pprint #cell magic %%writefile test.py #把代码写进py文件 for item in range(100): print(item) %%timeit 100 #100,000执行的时间 !python -m pip install jupyter_contrib_nbextensions --user !jupyter contrib nbextension install --user --skip-running-check #这里报错，使用conda安装即可 !conda install -c conda-forge jupyter_contrib_nbextensions !pip install --user jupyter_nbextensions_configurator !jupyter nbextensions_configurator enable --user #jupyter 扩展下载，支持目录 "
},
{
	"uri": "https://lczen.github.io/en/categories/hugo%E5%AE%89%E8%A3%85/",
	"title": "hugo安装",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/hugo%E5%AE%89%E8%A3%85%E7%BD%91%E7%AB%99%E6%8C%87%E4%BB%A4/",
	"title": "hugo安装指令",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "hugo安装指令 root目录下config.toml中的头部要改成： baseURL = \u0026quot;/\u0026quot; themesDir = \u0026quot;themes\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;Zen LU\u0026quot; theme = \u0026quot;m10c\u0026quot; brew install hugo hugo new site zenblog cd zenblog git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c cd themes ls cd .. hugo server -t m10c --buildDrafts hugo new post/blog.md hugo --theme=m10c --baseUrl=\u0026quot;https://lczen.github.io/\u0026quot; --buildDrafts cd public git init git add . git commit -m \u0026quot;我的hugo文件第一次提交\u0026quot; git remote add origin https://github.com/lczen/lczen.github.io.git git pull origin master --allow-unrelated-histories(我第二次换主题的时候用了这个) git push -u origin master #后面每次更新直接用下面代码： 修改以后： cd /users/zen/xiaolou hugo --theme=zzo --baseUrl=\u0026quot;https://lczen.github.io/\u0026quot; --buildDrafts cd public git init git add . git remote add origin https://github.com/lczen/lczen.github.io.git git commit -m “justmac” git pull origin master --allow-unrelated-histories git push -u origin master markdown显示图片 "
},
{
	"uri": "https://lczen.github.io/en/archive/",
	"title": "Archive",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Archive Page",
	"content": "archive page\n"
},
{
	"uri": "https://lczen.github.io/en/about/",
	"title": "About",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Hugo, the world’s fastest framework for building websites",
	"content": "Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n"
},
{
	"uri": "https://lczen.github.io/en/pt/",
	"title": "Presentations",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Presentation list with reveal.js",
	"content": ""
}]