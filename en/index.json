[
{
	"uri": "https://lczen.github.io/en/showcase/hugo/hugo-theme-zzo/",
	"title": "Hugo Zzo Theme",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Make a blog with hugo zzo theme!",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/showcase/hugo/hugo-theme-zdoc/",
	"title": "Hugo zDoc Theme",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Make a documentation with hugo zdoc theme!",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/showcase/hugo/",
	"title": "Hugo",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Hugo theme collection",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/showcase/",
	"title": "Showcase overview",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "My portfolio, repos, works overview page",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/",
	"title": "Posts",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Post page",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/categories/python%E5%9F%BA%E7%A1%80/",
	"title": "python基础",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/basicpractice/",
	"title": "小练习",
	"tags": ["练习题"],
	"categories": [],
	"series": [],
	"description": "",
	"content": "指定str位置，并更改该位置的值 1.实现一个功能，用户输入一个字符串，修改字符串中哪个位置，程序就会输出修改后的结果。（输入用input函数） 比如输入： 'fkjava.ipg' 6 - 程序输出：'fkjana-ipg' 我的理解：str不能根据index改变对应位置的值，而list可以。list转换成str用str的join函数。 1 2 3 4 5 6 7 8  s = input(\u0026#39;请输入一个字符串：\u0026#39;) k = input(\u0026#39;请输入要修改的位置和要修改成的符号，用空格分开：\u0026#39;) num = int(k[0]) # 要修改的index sub = k[2] # 要替换的字符 list_s = list(s) # 因为字符串是不可变的数据类型，我们字符串变成列表 list_s[num] = sub # 替换对应位置的字符 s = \u0026#39;\u0026#39;.join(list_s) print(\u0026#39;结果是：\u0026#39;, s)   找子串的数量 2.用户输入一个字符串和一个子串，程序会输出给定的子串在目标字符串中出现的次数。字符串遍历从左到右，而不是从右到左。 例如给定 'ABCDCDC' 和 'CDC' ，程序输出 '2' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  #法一，利用str的find方法 s = input(\u0026#39;输入字符串\u0026#39;) sub_s = input(\u0026#39;输入子字符串\u0026#39;) index = 0 count = 0 for i in range(len(s)+1): if s.find(sub_s,index) != -1: count += 1 index = s.find(sub_s,s.find(sub_s,index)+1) print(count) #法二：关键点，s[i:i+len_ss] == ss s = input(\u0026#39;请输入一个字符串：\u0026#39;) ss = input(\u0026#39;请输入要查找的字串：\u0026#39;) num = 0 # 创建最后输出用的变量 len_ss = len(ss) # 我们的思路是通过切片来取出 s 中的一部分判断是否和子串 ss 一致，所以这里要先知道 ss 的长度 for i in range(len(s) - len_ss + 1): # 防止后面做切片的时候索引超出上界，这里我们先减掉 ss 的长度，最后一位数不被包括，所以 +1 if s[i] == ss[0]: # 判断每个字符和 ss 开头字符是否匹配 if s[i:i+len_ss] == ss: # 判断接下来的 len_ss 长度的字符是否与 ss 一致 num += 1 print(num)   把输入数据封装成元祖 3.提示用户输入N个字符串（N自己定义），将他们封装成元组，然后计算该元组乘以3再加上（'hello','world'）的结果。 keypoint:列表可以强转换成元组，元组+元组=元组 1 2 3 4 5  s = input(\u0026#39;请输入一些字符串，用空格隔开：\u0026#39;) list_s = s.split(\u0026#39;\u0026#39;) tuple_s = tuple(list_s) result = tuple_s * 3 + (\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;) print(result) # 主要观察结果的呈现形式，重点理解 元组 * 数字 的含义以及元组之间加法的用法   请输入一些字符串，用空格隔开：w ('w', 'w', 'w', 'hello', 'world') 列表append随机数 4.用户输入一个整数n，生成长度为n的列表，并将n个随机数放入列表中。（随机数可以参考random库，百度搜索 python random 即可） 1 2 3 4 5  num = int(input(\u0026#39;请用户输入一个整数：\u0026#39;))# 这里要注意input函数返回的是字符串类型，需要转成整型 l = [] # 定义一个空列表，用来装后面生成的随机数 for i in range(num): # 循环n次 l.append(r.random()) # 这里数字范围不限，可以用random库里不同的函数来实现 print(l)   将n个随机的奇数放入列表 5.用户输入一个整数n，生成长度为n的列表，并将n个随机的奇数放入列表中。 1 2 3 4 5 6 7 8 9  num = int(input(\u0026#39;请用户输入一个整数：\u0026#39;)) l = [0] * num # 这道题我们换一个思路，先生成列表，用0站位，然后我们替换里面的数字 for i in range(num): # 遍历l，对每个0做替换 while True: # while True 为死循环，当满足条件时我们用break打破循环 n = r.randint(1, 100) # 生成1-100之间的随机整数 if n%2 == 1: l[i] = n break print(l)   choice 6.用户输入一个整数n，生成长度为n的列表，并将n个随机的大写字符放入列表中。 1 2 3 4 5  num = int(input(\u0026#39;请用户输入一个整数：\u0026#39;)) l = [] for i in range(num): l.append(r.choice(\u0026#39;abcdefghijklmnopqrstuvwxyz\u0026#39;).upper()) # 用upper()变成大写，可以思考还有其他生成随机字符的方式吗？ print(l)   输出整数的最大值 7.用户输入以空格分隔的多个整数，输出这些整数的最大值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #法一 list.sort 列表表达式 nums = input(\u0026#39;请输入一些整数，以空格分隔：\u0026#39;) list_nums = nums.split(\u0026#39;\u0026#39;) list_int_nums = [int(item) for item in list_nums] list_int_nums.sort() print(list_int_nums[len(list_int_nums)-1]) #法二 nums = input(\u0026#39;请输入一些整数，以空格分隔：\u0026#39;) list_nums = nums.split(\u0026#39;\u0026#39;) list_int_nums = [] for i in range(len(list_nums)): # 第一个循环，我们把所有数字从字符串变成整型 num = int(list_nums[i]) list_int_nums.append(num) a = -99999999 for i in list_int_nums: # 第二个循环，a为目前最大数，遍历列表，如果当前数字比a大，把当前值赋值给a if i \u0026gt; a: a = i print(\u0026#39;最大的数为：\u0026#39;, a)   统计字符串中每个字母的次数* 8.用户输入N个大写字母，使用dict统计用户输入的每个字母的次数。 1 2 3 4 5 6 7 8  s = input(\u0026#39;请输入一些大写字母：\u0026#39;) d = dict() for i in s: if i in d.keys(): d[i] += 1 else: d[i] = 1 print(d)   输出等腰三角形 9.使用循环输出等腰三角形，层数由用户输入（input），输出结果如下（输入3）： * * *** keypoint:用数学方式去理解，*的规律是2n-1 1 2 3  n = int(input(\u0026#39;请输入三角形的层数：\u0026#39;)) for i in range(1, n+1): print((n-i)*\u0026#39;\u0026#39; + (2*i-1)*\u0026#39;*\u0026#39; + (n-i)*\u0026#39;\u0026#39;)   请输入三角形的层数：3 * *** ***** 九九乘法表 10.使用循环输出九九乘法表。输入结果如下： 1 * 1 = 1 1 * 2 = 2 2 * 2 = 4 ....... 1 2 3 4  for i in range(1, 10): for j in range(1, i+1): print(\u0026#39;{}x{}={}\\t\u0026#39;.format(j, i, i*j), end=\u0026#39;\u0026#39;) # \\t为制表符 print()   1x1=1\t1x2=2\t2x2=4\t1x3=3\t2x3=6\t3x3=9\t1x4=4\t2x4=8\t3x4=12\t4x4=16\t1x5=5\t2x5=10\t3x5=15\t4x5=20\t5x5=25\t1x6=6\t2x6=12\t3x6=18\t4x6=24\t5x6=30\t6x6=36\t1x7=7\t2x7=14\t3x7=21\t4x7=28\t5x7=35\t6x7=42\t7x7=49\t1x8=8\t2x8=16\t3x8=24\t4x8=32\t5x8=40\t6x8=48\t7x8=56\t8x8=64\t1x9=9\t2x9=18\t3x9=27\t4x9=36\t5x9=45\t6x9=54\t7x9=63\t8x9=72\t9x9=81\t"
},
{
	"uri": "https://lczen.github.io/en/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/",
	"title": "练习题",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/regular/",
	"title": "Regular",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "正则表达式 re模块 学习网站：http://regexr.com/\nPython通过re模块提供对正则表达式的支持。\n使用re的一般步骤是\n 1.将正则表达式的字符串形式编译为Pattern实例 2.使用Pattern实例处理文本并获得匹配结果（一个Match实例） 3.使用Match实例获得信息，进行其他的操作。  1 2 3 4 5 6 7 8 9 10 11 12  # encoding: UTF-8 import re # 将正则表达式编译成Pattern对象 pattern = re.compile(r\u0026#39;hello.*\\!\u0026#39;) # 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回None match = pattern.match(\u0026#39;hello, hanxiaoyang! How are you?\u0026#39;) if match: # 使用Match获得分组信息 print(match.group())   re.compile(strPattern[, flag]):\n这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。\n第二个参数flag是匹配模式，取值可以使用按位或运算符'|'表示同时生效，比如re.I | re.M。\n当然，你也可以在regex字符串中指定模式，比如re.compile(\u0026lsquo;pattern\u0026rsquo;, re.I | re.M)等价于re.compile('(?im)pattern\u0026rsquo;)\nflag可选值有：\n re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同） re.M(MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图） re.S(DOTALL): 点任意匹配模式，改变\u0026rsquo;.\u0026lsquo;的行为 re.L(LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 re.U(UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 re.X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的：  1 2 3 4  regex_1 = re.compile(r\u0026#34;\u0026#34;\u0026#34;\\d + # 数字部分\\. # 小数点部分\\d * # 小数的数字部分\u0026#34;\u0026#34;\u0026#34;, re.X) regex_2 = re.compile(r\u0026#34;\\d+\\.\\d*\u0026#34;)   Match 小象学院《机器学习集训营》课程资料 by @寒小阳\nMatch对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。\nmatch属性：\n string: 匹配时使用的文本。 re: 匹配时使用的Pattern对象。 pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。 lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。  match方法：\n group([group1, …]): 获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 groups([default]): 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 groupdict([default]): 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。 start([group]): 返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。 end([group]): 返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。 span([group]): 返回(start(group), end(group))。 expand(template): 将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符'0\u0026rsquo;，只能使用\\g\u0026lt;1\u0026gt;0。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import re m = re.match(r\u0026#39;(\\w+) (\\w+)(?P\u0026lt;sign\u0026gt;.*)\u0026#39;, \u0026#39;hello hanxiaoyang!\u0026#39;)#?P\u0026lt;sign\u0026gt;.*是标点的意思 print \u0026#34;m.string:\u0026#34;, m.string print \u0026#34;m.re:\u0026#34;, m.re print \u0026#34;m.pos:\u0026#34;, m.pos print \u0026#34;m.endpos:\u0026#34;, m.endpos print \u0026#34;m.lastindex:\u0026#34;, m.lastindex print \u0026#34;m.lastgroup:\u0026#34;, m.lastgroup print \u0026#34;m.group(1,2):\u0026#34;, m.group(1, 2) print \u0026#34;m.groups():\u0026#34;, m.groups() print \u0026#34;m.groupdict():\u0026#34;, m.groupdict() print \u0026#34;m.start(2):\u0026#34;, m.start(2) print \u0026#34;m.end(2):\u0026#34;, m.end(2) print \u0026#34;m.span(2):\u0026#34;, m.span(2) print r\u0026#34;m.expand(r\u0026#39;\\2 \\1\\3\u0026#39;):\u0026#34;, m.expand(r\u0026#39;\\2 \\1\\3\u0026#39;)   m.string: hello hanxiaoyang! m.re: \u0026lt;_sre.SRE_Pattern object at 0x10b111be0\u0026gt; m.pos: 0 m.endpos: 18 m.lastindex: 3 m.lastgroup: sign m.group(1,2): ('hello', 'hanxiaoyang') m.groups(): ('hello', 'hanxiaoyang', '!') m.groupdict(): {'sign': '!'} m.start(2): 6 m.end(2): 17 m.span(2): (6, 17) m.expand(r'\\2 \\1\\3'): hanxiaoyang hello! Pattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。 Pattern不能直接实例化，必须使用re.compile()进行构造。 Pattern提供了几个可读属性用于获取表达式的相关信息： * pattern: 编译时用的表达式字符串。 * flags: 编译时用的匹配模式。数字形式。 * groups: 表达式中分组的数量。 * groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。 1 2 3 4 5 6 7  import re p = re.compile(r\u0026#39;(\\w+) (\\w+)(?P\u0026lt;sign\u0026gt;.*)\u0026#39;, re.DOTALL) print \u0026#34;p.pattern:\u0026#34;, p.pattern print \u0026#34;p.flags:\u0026#34;, p.flags print \u0026#34;p.groups:\u0026#34;, p.groups print \u0026#34;p.groupindex:\u0026#34;, p.groupindex   p.pattern: (\\w+) (\\w+)(?P\u0026lt;sign\u0026gt;.*) p.flags: 16 p.groups: 3 p.groupindex: {'sign': 3} pattern匹配与替换  match(string[, pos[, endpos]]) | re.match(pattern, string[, flags]): 这个方法将从string的pos下标处起尝试匹配pattern:  如果pattern结束时仍可匹配，则返回一个Match对象 如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。 pos和endpos的默认值分别为0和len(string)。 **注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符'$\u0026rsquo;。 **   search(string[, pos[, endpos]]) | re.search(pattern, string[, flags]): 这个方法从string的pos下标处起尝试匹配pattern  如果pattern结束时仍可匹配，则返回一个Match对象 若无法匹配，则将pos加1后重新尝试匹配，直到pos=endpos时仍无法匹配则返回None。 pos和endpos的默认值分别为0和len(string))    1 2 3 4 5 6 7 8 9 10 11 12 13  # encoding: UTF-8  import re # 将正则表达式编译成Pattern对象  pattern = re.compile(r\u0026#39;H.*g\u0026#39;) # 使用search()查找匹配的子串，不存在能匹配的子串时将返回None  # 这个例子中使用match()无法成功匹配  match = pattern.search(\u0026#39;hello Hanxiaoyang!\u0026#39;) if match: # 使用Match获得分组信息  print match.group()#Hanxiaoyang    split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]):  按照能够匹配的子串将string分割后返回列表。 maxsplit用于指定最大分割次数，不指定将全部分割。    1 2 3 4  import re p = re.compile(r\u0026#39;\\d+\u0026#39;) print p.split(\u0026#39;one12306two2three3four4\u0026#39;)   ['one', 'two', 'three', 'four', '']  findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags]):  搜索string，以列表形式返回全部能匹配的子串。    1 2 3 4  import re p = re.compile(r\u0026#39;\\d+\u0026#39;) print p.findall(\u0026#39;one12306two2three3four4\u0026#39;)   ['12306', '2', '3', '4']  **finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags]): **  搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。    1 2 3 4 5  import re p = re.compile(r\u0026#39;\\d+\u0026#39;) for m in p.finditer(\u0026#39;one1two2three3four4\u0026#39;): print m.group()   1 2 3 4  **sub(repl, string[, count]) | re.sub(pattern, repl, string[, count]): **  使用repl替换string中每一个匹配的子串后返回替换后的字符串。  当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。 当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。\ncount用于指定最多替换次数，不指定时全部替换。      1 2 3 4 5 6 7 8 9 10 11  import re p = re.compile(r\u0026#39;(\\w+) (\\w+)\u0026#39;) s = \u0026#39;i say, hello hanxiaoyang!\u0026#39; print p.sub(r\u0026#39;\\2 \\1\u0026#39;, s) def func(m): return m.group(1).title() + \u0026#39;\u0026#39; + m.group(2).title() print p.sub(func, s)   say i, hanxiaoyang hello! I Say, Hello Hanxiaoyang!  **subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]): **  返回 (sub(repl, string[, count]), 替换次数)。    import re p = re.compile(r'(\\w+) (\\w+)') s = 'i say, hello hanxiaoyang!' print p.subn(r'\\2 \\1', s) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print p.subn(func, s) ('say i, hanxiaoyang hello!', 2) ('I Say, Hello Hanxiaoyang!', 2) "
},
{
	"uri": "https://lczen.github.io/en/posts/python/",
	"title": "Python学习",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "Python基础 Python运行方式 解释运行 新建py文件，直接运行\n1 2  %%writefile print_str.py print(\u0026#34;欢迎大家学习课程内容！\u0026#34;)   交互运行 ipython, notebook\nPython标识符 1 2 3 4  #如以下标识符取名错误 for=\u0026#39;chinahadoop.cn\u0026#39; 7a=8 str=\u0026#39;小象学院\u0026#39;   好的命名习惯   变量，函数或方法:salary,houseworker,booksname 常量：INTEREST_RATES 类：BankAccount,Employee,Company,OrderedDict #骆峰命名法   操作符优先级 第1名 - 函数调用、寻址、下标 第2名 - 幂运算 ** 第3名 - 翻转运算符 ~ 第4名 - 正负号 第5名 - *、/、% 第6名 - +、- 取商运算和开方 a//b #取商\na**0.5 #开方\n7.in和not in操作适用于str 1 2 3  websiteUrl=\u0026#39;chinahadoop.cn\u0026#39; if \u0026#39;.net\u0026#39; not in websiteUrl: print (\u0026#39;.net not in it\u0026#39;)   8.赋值操作 1 2 3  a=b=100 a,b,c=100,200,200 a,b=b,a#交换赋值   基本数据类型与数据结构 基本数据类型 类型：\nnumber：\nint,float,complex\nboolean,String,List,Tuple,Dictionary\n类型转换：\nint(a),str(a),eval(x),tuple(x),list(x),chr(x) # 整数转换为字符\n数值型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #进制转换 a=0b0101001#bin() b=0o4#oct() c=0x28#hex() #浮点型 pi=3.1415 #科学计算法 c=5e13 print(c) #数字的正负无穷 #float(\u0026#39;inf\u0026#39;)正无穷 #float(\u0026#39;-inf\u0026#39;)负无穷 if 99999999999999999\u0026lt;float(\u0026#39;inf\u0026#39;): print(\u0026#39;you win!\u0026#39;) #复数 a=4.3+22j type(a) #数值类型转换 a=4.48 b=8 int(a) # 保留n位小数四舍五入 round(pi,3)   字符串型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  str2=\u0026#39;chinahadoop.cn\u0026#39; #str2[start🔚stride] #切片访问的特点：左闭右开[) str2[0::2] #从index为0到结尾，每隔2-1=1个字符取一次 #格式化访问1 companyName=\u0026#39;chinahadoop\u0026#39; str3=\u0026#39;http://{}.cn\u0026#39; print(str3.format(companyName)) #格式化访问2 print(\u0026#34;Company name is %s\u0026#34; %companyName) #格式化访问3 _=\u0026#39;Python 3.6\u0026#39;#fstring only can be used under version 3.6 str4=f\u0026#34;fstring is new feature of {_}\u0026#34; str4 #查找与替换 str3.find(\u0026#39;o\u0026#39;) str3.replace(\u0026#39;.cn\u0026#39;,\u0026#39;.net\u0026#39;) #统计 str3.count(\u0026#39;cn\u0026#39;)   数据结构 列表list 列表[]:任意元素类型对象的序列\n1 2 3 4 5 6 7 8 9  #append和extend # 列表追加 l2.append([\u0026#39;last\u0026#39;, \u0026#39;elem\u0026#39;]) #追加1个元素，这个元素是列表 l2.extend([\u0026#39;new\u0026#39;, \u0026#39;item\u0026#39;]) #追加列表 l2 + l1 #追加列表 # 列表删除元素 l2.pop() #返回最尾部元素，并删除该元素 l2.remove(\u0026#39;china\u0026#39;) #移除列表中的某个值的第一个匹配项，没有返回值   1 2 3 4 5  # 字符串列表的拼接与分割 l3 = [\u0026#39;I\u0026#39;, \u0026#39;love\u0026#39;, \u0026#39;China\u0026#39;] \u0026#34;_\u0026#34;.join(l3) #用下划线拼接列表元素(需要是字符串) a = \u0026#34;#\u0026#34;.join(l3) a.split(\u0026#34;#\u0026#34;) #用井号切分字符串生成列表   1 2 3 4 5 6 7 8 9 10 11 12  # 列表排序 my_list = [5,1,2,4,3] my_list.sort() #对my_list排序，直接改变my_list new_list = [5,1,2,4,3] sorted(new_list) #对new_list排序，以返回值返回排序结果，并不改变new_list # sorted高级用法 tmp_strs = [\u0026#39;aa\u0026#39;, \u0026#39;BBc\u0026#39;, \u0026#39;CCdd\u0026#39;, \u0026#39;zzmm\u0026#39;] sorted(tmp_strs) #按照字母序排序 sorted(tmp_strs, reverse=True) #按照字母序降序排序 sorted(tmp_strs, key=len) #根据key对元素做处理后的结果对原序列排序，这里的len是函数，返回字符串长度 sorted(tmp_strs, key=str.lower) #根据小写后的结果字母序排序   元组tuple 1 2 3 4 5 6 7 8 9  #元组()tuple,只读列表 t1=(1,2,3,4) #只读列表是真的只读吗？ t2=(1,2,3,[4,5,6]) t2[0]=11#报错 tup = (\u0026#39;physics\u0026#39;, \u0026#39;chemistry\u0026#39;, 1997, 2000) tup1 = (50,) #元组中只包含一个元素时，需要在元素后面添加逗号 tup[1:] #元组的切片拼接和list一样   集合set(去重非常好用) 1 2 3 4  #集合{}set：无序的不重复元素,集合中的对象，通常叫key s1={1,1,1,2,3,4,5,2,4,234} l2=[1,1,1,2,3,4,5,2,4,234] set(l2)   字典 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # 字典是另一种可变容器模型，且可存储任意类型对象。 # 字典的每个键值 key=\u0026gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 my_dict = {\u0026#39;HanXiaoyang\u0026#39;: 1234, \u0026#39;Jason\u0026#39;: 4567, \u0026#39;David\u0026#39;: 6789} #定义字典 ks = my_dict.keys() #取出所有的key vs = my_dict.values() #取出所有的values Hv = my_dict[\u0026#39;HanXiaoyang\u0026#39;] #根据key取对应的value Dv = my_dict.get(\u0026#39;XiaoMing\u0026#39;, 2345) #根据key去取value，如果key不存在返回默认值 my_dict[\u0026#39;HanXiaoyang\u0026#39;] = 7890 #改变字典中key对应的value值 flag = \u0026#39;DaDa\u0026#39; in my_dict #判断是否有某个key # 遍历字典元素 for key in my_dict: print(key,my_dict[key]) from collections import OrderedDict # 注意，字典是一种键值对数据结构，本身是无序的，如果需要顺序，可以用OrderedDict od1=OrderedDict()#按主键首次插入顺序进行排序 od1[\u0026#39;a\u0026#39;]=7 od1[\u0026#39;z\u0026#39;]=8 od1[\u0026#39;b\u0026#39;]=9   声明Statement与Expression表达式 1 2 3 4 5 6 7 8 9 10 11  #statement声明 a=\u0026#39;小象学院\u0026#39;#statement通常为赋值语句 b=100 c=a #Expression表达式 #值、变量和运算符共同组成的整体我们将其称为表达式。通常有值表达式、变量表达式、计算表达式、字符串表达式, b,b+100,a+\u0026#39;is amazing\u0026#39;,__builtins__ #exec执行声明语句,eval执行表达式 exec(\u0026#39;a=5\u0026#39;) b=3 eval(\u0026#39;a+b+5\u0026#39;)   判断：if， if else ,if elif elif与三元表达式 1  \u0026#39;a\u0026#39; if age\u0026gt;50 else \u0026#39;b\u0026#39;   列表推导式List Comprehensions，可迭代对象Iterable与迭代器iterator,生成器generator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #列表推导式：从一个列表中生成一个新的列表，简化了循环的写法 l1= [x+1 for x in range(30) if x%3==0] #新的list中的元素，来源于从0-29这个list中所有整除3的元素+1 l1=[0, 3, 6, 9, 12, 15, 18, 21, 24, 27] l2=iter(l1) l2.__next__() #可迭代对象Iterable：可以被for循环的对象统称为可迭代对象Iterable,list,str,dict这些都是可迭代类型 #迭代器Iterator：可以被next调用的迭代器。 #next(l1) #TypeError: \u0026#39;list\u0026#39; object is not an iterator #使用iter将一来个可迭代对象变为迭代器 l1=iter(l1) next(l1),next(l1) #生成器Generator：首先是一个迭代器，然后其内容是按需生成 #列表是一次性生成，缺点是当内容过大时会占用大量内容，那能不能用到多少生成多少呢？ #Python里一边循环一边计算(惰性计算)的迭代器称为生成器（Generator） #1.直接从列表表达式生成 g1= (x**2 for x in range(30) if x%2==0) type(g1) #\u0026lt;class \u0026#39;generator\u0026#39;\u0026gt; next(g1),next(g1),next(g1),next(g1),g1.__next__(),g1.__next__() #2.函数生成，与yield关键字 def g2_func(n): for i in range(n): yield i**2 g2=g2_func(7) next(g2),next(g2),g2.__next__(),g2.__next__(),g2.__next__(),g2.__next__() #yield from/子迭代器，后面直接是可迭代对象。 def yield_from_iter(iter_object): yield from iter_object y1=yield_from_iter(\u0026#39;China\u0026#39;) y1.__next__(),next(y1)   处理异常 1 2 3 4 5 6 7 8 9 10 11 12  #try-finally 无法是否捕获了异常，都会执行finally后的语句 x = 5 #y = 2 y = 0 try: result = x / y except ZeroDivisionError: print(\u0026#34;division by zero!\u0026#34;) else: print(\u0026#34;result is\u0026#34;, result) finally: print(\u0026#34;executing finally clause\u0026#34;)   函数定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  # 定义斐波那契数列 def fib(n): a, b =1, 1 for i in range(n): print(a, end=\u0026#34;\u0026#34;) a,b = b,a+b print() # 函数默认参数 def printinfo(name, age = 35): print(\u0026#34;姓名:\u0026#34;, name) print(\u0026#34;年龄:\u0026#34;, age) return #调用printinfo函数 printinfo(age=50, name=\u0026#34;隔壁老王\u0026#34;); printinfo(name=\u0026#34;隔壁老王\u0026#34;); def printinfo(arg1, *vartuple): \u0026#34;打印任何传入的参数\u0026#34; print(\u0026#34;输出:\u0026#34;) print(arg1) print(vartuple) return # 调用printinfo 函数 printinfo(10) printinfo(70, 60, 50) # python 使用 lambda 来创建匿名函数。lambda [arg1,arg2,.....argn]:expression sum = lambda arg1, arg2: arg1 + arg2; # 调用sum函数 print(\u0026#34;相加后的值为:\u0026#34;, sum( 10, 20 )) print(\u0026#34;相加后的值为:\u0026#34;, sum( 20, 30 ))   filter和map和reduce 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  #filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。 #判断是否为正数 def is_positive(x): return x \u0026gt; 0 result = filter(is_positive,[1,3,5,-1,-10,0]) list(result) #map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 ## 每个元素求平方 def f(x): return x * x result = map(f,[1,3,5,-1,-10,0]) list(result) #reduce()函数也是Python内置的一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数 f，一个list，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。 from functools import reduce ## 求和 def add(x,y): return x + y result = reduce(add,[1,3,5,-1,-10,0])   文件操作 文件读 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  # 要以读文件的模式打开一个文件对象，使用Python内置的`open()`函数，传入文件名和标示符： f = open(\u0026#39;print_str.py\u0026#39;, \u0026#39;r\u0026#39;) # 如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示： f.read() # 最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源 f.close() # 异常处理模式 try: f = open(\u0026#39;/path/to/file\u0026#39;, \u0026#39;r\u0026#39;) print(f.read()) except Exception as e: print e finally: if f: f.close() # 逐行读取 with open(\u0026#39;test.py\u0026#39;, \u0026#39;r\u0026#39;) as f: for line in f.readlines(): print(line.strip())   文件写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  with open(\u0026#39;test.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;Hello, world!\\n\u0026#39;) f.write(\u0026#39;new line\u0026#39;) lines = [\u0026#39;Hello, python!\\n\u0026#39;, \u0026#39;New text!\u0026#39;] with open(\u0026#39;new.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.writelines(lines) # 需要用到os内置模块 import os # 列举当前绝对路径 os.path.abspath(\u0026#39;.\u0026#39;) # 新建文件夹 os.mkdir(\u0026#39;./testdir\u0026#39;) # 文件重命名 os.rename(\u0026#39;test.txt\u0026#39;, \u0026#39;test2.txt\u0026#39;) # 列出当前路径下的所有文件夹 [x for x in os.listdir(\u0026#39;.\u0026#39;) if os.path.isdir(x)] # 列出当前路径下的所有python脚本文件 [x for x in os.listdir(\u0026#39;.\u0026#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==\u0026#39;.py\u0026#39;]   面向对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 类的设计与创建 # 使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾，类的主体由类成员，方法，数据属性组成 class Employee: \u0026#34;所有员工的基类\u0026#34; empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print(\u0026#34;总共雇员数量 %d\u0026#34; % Employee.empCount) def displayEmployee(self): print(\u0026#34;姓名: \u0026#34;, self.name, \u0026#34;, 工资: \u0026#34;, self.salary) # empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。 # 第一种方法__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法 # self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。 # 创建对象 \u0026#34;创建 Employee 类的第一个对象\u0026#34; emp1 = Employee(\u0026#34;张三\u0026#34;, 2000) \u0026#34;创建 Employee 类的第二个对象\u0026#34; emp2 = Employee(\u0026#34;李四\u0026#34;, 5000) # 调用成员函数 emp1.displayEmployee() emp2.displayEmployee() print(\u0026#34;总共雇员数%d\u0026#34; % Employee.empCount)   "
},
{
	"uri": "https://lczen.github.io/en/posts/jupyter%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/",
	"title": "jupyter小技巧",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "1.jupyter安装 1 2 3 4  conda install jupyter notebook # 安装anaconda之后，下载jupyter notebook conda install -c conda-forge jupyter_contrib_nbextensions # jupyter notebook扩展安装 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple autopep8 # 代码自动规范化包   2.jupyter magic关键字 %quickref %lsmagic #查看magic有哪些magic命令 #line magic %config ZMQInteractiveShell.ast_node_interactivity='all'#这里是打印多行的开关 off打印多行 %pprint #cell magic %%writefile test.py #把代码写进py文件 for item in range(100): print(item) %%timeit 100 #100,000执行的时间 !python -m pip install jupyter_contrib_nbextensions --user !jupyter contrib nbextension install --user --skip-running-check #这里报错，使用conda安装即可 !conda install -c conda-forge jupyter_contrib_nbextensions !pip install --user jupyter_nbextensions_configurator !jupyter nbextensions_configurator enable --user #jupyter 扩展下载，支持目录 "
},
{
	"uri": "https://lczen.github.io/en/categories/hugo%E5%AE%89%E8%A3%85/",
	"title": "hugo安装",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/posts/hugo%E5%AE%89%E8%A3%85%E7%BD%91%E7%AB%99%E6%8C%87%E4%BB%A4/",
	"title": "hugo安装指令",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "hugo安装指令 root目录下config.toml中的头部要改成： baseURL = \u0026quot;/\u0026quot; themesDir = \u0026quot;themes\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;Zen LU\u0026quot; theme = \u0026quot;m10c\u0026quot; brew install hugo hugo new site zenblog cd zenblog git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c cd themes ls cd .. hugo server -t m10c --buildDrafts hugo new post/blog.md hugo --theme=m10c --baseUrl=\u0026quot;https://lczen.github.io/\u0026quot; --buildDrafts cd public git init git add . git commit -m \u0026quot;我的hugo文件第一次提交\u0026quot; git remote add origin https://github.com/lczen/lczen.github.io.git git pull origin master --allow-unrelated-histories(我第二次换主题的时候用了这个) git push -u origin master #后面每次更新直接用下面代码： 修改以后： cd /users/zen/my-site hugo --theme=hugo_theme_adam_eve --baseUrl=\u0026quot;https://lczen.github.io/\u0026quot; --buildDrafts cd public git init git add . git remote add origin https://github.com/lczen/lczen.github.io.git git commit -m “justmac” git pull origin master --allow-unrelated-histories git push -u origin master "
},
{
	"uri": "https://lczen.github.io/en/archive/",
	"title": "Archive",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Archive Page",
	"content": "archive page\n"
},
{
	"uri": "https://lczen.github.io/en/about/",
	"title": "About",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Hugo, the world’s fastest framework for building websites",
	"content": "Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n"
},
{
	"uri": "https://lczen.github.io/en/pt/",
	"title": "Presentations",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Presentation list with reveal.js",
	"content": ""
},
{
	"uri": "https://lczen.github.io/en/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]